// File generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR: &'static str = include_str!("/home/onlycs/code/oreobot/schema.prisma");
static DATABASE_STR: &'static str = "postgresql";
pub use _prisma::*;
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum ChannelType {
    #[serde(rename = "Text")]
    Text,
    #[serde(rename = "News")]
    News,
    #[serde(rename = "Stage")]
    Stage,
    #[serde(rename = "Voice")]
    Voice,
}
impl ToString for ChannelType {
    fn to_string(&self) -> String {
        match self {
            Self::Text => "Text".to_string(),
            Self::News => "News".to_string(),
            Self::Stage => "Stage".to_string(),
            Self::Voice => "Voice".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum InteractionType {
    #[serde(rename = "Command")]
    Command,
    #[serde(rename = "ModalSubmit")]
    ModalSubmit,
    #[serde(rename = "MessageComponent")]
    MessageComponent,
}
impl ToString for InteractionType {
    fn to_string(&self) -> String {
        match self {
            Self::Command => "Command".to_string(),
            Self::ModalSubmit => "ModalSubmit".to_string(),
            Self::MessageComponent => "MessageComponent".to_string(),
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: ::prisma_client_rust::Data>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<
            'batch,
            T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
            Marker,
        >(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<
            <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
        > {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub fn user(&self) -> super::user::Actions {
            super::user::Actions { client: &self.0 }
        }
        pub fn role(&self) -> super::role::Actions {
            super::role::Actions { client: &self.0 }
        }
        pub fn attachment(&self) -> super::attachment::Actions {
            super::attachment::Actions { client: &self.0 }
        }
        pub fn message(&self) -> super::message::Actions {
            super::message::Actions { client: &self.0 }
        }
        pub fn message_pin(&self) -> super::message_pin::Actions {
            super::message_pin::Actions { client: &self.0 }
        }
        pub fn channel(&self) -> super::channel::Actions {
            super::channel::Actions { client: &self.0 }
        }
        pub fn channel_category(&self) -> super::channel_category::Actions {
            super::channel_category::Actions { client: &self.0 }
        }
        pub fn command_interaction_data(&self) -> super::command_interaction_data::Actions {
            super::command_interaction_data::Actions { client: &self.0 }
        }
        pub fn interaction(&self) -> super::interaction::Actions {
            super::interaction::Actions { client: &self.0 }
        }
        pub fn impersonated_message_data(&self) -> super::impersonated_message_data::Actions {
            super::impersonated_message_data::Actions { client: &self.0 }
        }
        pub fn news_in_chat(&self) -> super::news_in_chat::Actions {
            super::news_in_chat::Actions { client: &self.0 }
        }
        pub fn logless_roles(&self) -> super::logless_roles::Actions {
            super::logless_roles::Actions { client: &self.0 }
        }
        pub fn user_settings_data(&self) -> super::user_settings_data::Actions {
            super::user_settings_data::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum UserScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "username")]
        Username,
        #[serde(rename = "nickname")]
        Nickname,
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "verified")]
        Verified,
        #[serde(rename = "bot")]
        Bot,
        #[serde(rename = "removed")]
        Removed,
    }
    impl ToString for UserScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Username => "username".to_string(),
                Self::Nickname => "nickname".to_string(),
                Self::Admin => "admin".to_string(),
                Self::Verified => "verified".to_string(),
                Self::Bot => "bot".to_string(),
                Self::Removed => "removed".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum RoleScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "color")]
        Color,
        #[serde(rename = "color_role")]
        ColorRole,
        #[serde(rename = "deleted")]
        Deleted,
    }
    impl ToString for RoleScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::Color => "color".to_string(),
                Self::ColorRole => "color_role".to_string(),
                Self::Deleted => "deleted".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum AttachmentScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "filename")]
        Filename,
        #[serde(rename = "url")]
        Url,
        #[serde(rename = "size_bytes")]
        SizeBytes,
        #[serde(rename = "message_id")]
        MessageId,
        #[serde(rename = "deleted")]
        Deleted,
    }
    impl ToString for AttachmentScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Filename => "filename".to_string(),
                Self::Url => "url".to_string(),
                Self::SizeBytes => "size_bytes".to_string(),
                Self::MessageId => "message_id".to_string(),
                Self::Deleted => "deleted".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum MessageScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "content")]
        Content,
        #[serde(rename = "author_id")]
        AuthorId,
        #[serde(rename = "channel_id")]
        ChannelId,
        #[serde(rename = "created")]
        Created,
        #[serde(rename = "updated_at")]
        UpdatedAt,
        #[serde(rename = "deleted")]
        Deleted,
        #[serde(rename = "edited")]
        Edited,
    }
    impl ToString for MessageScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Content => "content".to_string(),
                Self::AuthorId => "author_id".to_string(),
                Self::ChannelId => "channel_id".to_string(),
                Self::Created => "created".to_string(),
                Self::UpdatedAt => "updated_at".to_string(),
                Self::Deleted => "deleted".to_string(),
                Self::Edited => "edited".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum MessagePinScalarFieldEnum {
        #[serde(rename = "pinned_message_id")]
        PinnedMessageId,
        #[serde(rename = "original_id")]
        OriginalId,
        #[serde(rename = "removed")]
        Removed,
        #[serde(rename = "removed_reason")]
        RemovedReason,
    }
    impl ToString for MessagePinScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::PinnedMessageId => "pinned_message_id".to_string(),
                Self::OriginalId => "original_id".to_string(),
                Self::Removed => "removed".to_string(),
                Self::RemovedReason => "removed_reason".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ChannelScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "topic")]
        Topic,
        #[serde(rename = "nsfw")]
        Nsfw,
        #[serde(rename = "kind")]
        Kind,
        #[serde(rename = "category_id")]
        CategoryId,
        #[serde(rename = "deleted")]
        Deleted,
    }
    impl ToString for ChannelScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::Topic => "topic".to_string(),
                Self::Nsfw => "nsfw".to_string(),
                Self::Kind => "kind".to_string(),
                Self::CategoryId => "category_id".to_string(),
                Self::Deleted => "deleted".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ChannelCategoryScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "deleted")]
        Deleted,
    }
    impl ToString for ChannelCategoryScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::Deleted => "deleted".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum CommandInteractionDataScalarFieldEnum {
        #[serde(rename = "command_id")]
        CommandId,
        #[serde(rename = "command_name")]
        CommandName,
        #[serde(rename = "interaction_id")]
        InteractionId,
    }
    impl ToString for CommandInteractionDataScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::CommandId => "command_id".to_string(),
                Self::CommandName => "command_name".to_string(),
                Self::InteractionId => "interaction_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum InteractionScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "kind")]
        Kind,
        #[serde(rename = "token")]
        Token,
        #[serde(rename = "application_id")]
        ApplicationId,
        #[serde(rename = "created")]
        Created,
        #[serde(rename = "reusable")]
        Reusable,
        #[serde(rename = "channel_id")]
        ChannelId,
        #[serde(rename = "invoker_id")]
        InvokerId,
        #[serde(rename = "custom_id")]
        CustomId,
    }
    impl ToString for InteractionScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Kind => "kind".to_string(),
                Self::Token => "token".to_string(),
                Self::ApplicationId => "application_id".to_string(),
                Self::Created => "created".to_string(),
                Self::Reusable => "reusable".to_string(),
                Self::ChannelId => "channel_id".to_string(),
                Self::InvokerId => "invoker_id".to_string(),
                Self::CustomId => "custom_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ImpersonatedMessageDataScalarFieldEnum {
        #[serde(rename = "source_id")]
        SourceId,
        #[serde(rename = "fake_author_id")]
        FakeAuthorId,
        #[serde(rename = "fake_message_id")]
        FakeMessageId,
    }
    impl ToString for ImpersonatedMessageDataScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::SourceId => "source_id".to_string(),
                Self::FakeAuthorId => "fake_author_id".to_string(),
                Self::FakeMessageId => "fake_message_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum NewsInChatScalarFieldEnum {
        #[serde(rename = "source_id")]
        SourceId,
        #[serde(rename = "fake_message_id")]
        FakeMessageId,
    }
    impl ToString for NewsInChatScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::SourceId => "source_id".to_string(),
                Self::FakeMessageId => "fake_message_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum LoglessRolesScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
    }
    impl ToString for LoglessRolesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum UserSettingsDataScalarFieldEnum {
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "pin_confirm")]
        PinConfirm,
    }
    impl ToString for UserSettingsDataScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::UserId => "user_id".to_string(),
                Self::PinConfirm => "pin_confirm".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum NullsOrder {
        #[serde(rename = "first")]
        First,
        #[serde(rename = "last")]
        Last,
    }
    impl ToString for NullsOrder {
        fn to_string(&self) -> String {
            match self {
                Self::First => "first".to_string(),
                Self::Last => "last".to_string(),
            }
        }
    }
    impl Into<::prisma_client_rust::PrismaValue> for SortOrder {
        fn into(self) -> ::prisma_client_rust::PrismaValue {
            match self {
                SortOrder::Asc => ::prisma_client_rust::PrismaValue::String("asc".to_string()),
                SortOrder::Desc => ::prisma_client_rust::PrismaValue::String("desc".to_string()),
            }
        }
    }
    pub mod read_filters {
        #[derive(Debug, Clone)]
        pub enum BigIntFilter {
            Equals(i64),
            InVec(Vec<i64>),
            NotInVec(Vec<i64>),
            Lt(i64),
            Lte(i64),
            Gt(i64),
            Gte(i64),
            Not(i64),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BigIntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum BigIntNullableFilter {
            Equals(Option<i64>),
            InVec(Vec<i64>),
            NotInVec(Vec<i64>),
            Lt(i64),
            Lte(i64),
            Gt(i64),
            Gte(i64),
            Not(Option<i64>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BigIntNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum BooleanFilter {
            Equals(bool),
            Not(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BooleanFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum StringNullableFilter {
            Equals(Option<String>),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(Option<String>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum DateTimeFilter {
            Equals(
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            ),
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::DateTime(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum ChannelTypeFilter {
            Equals(super::super::ChannelType),
            InVec(Vec<super::super::ChannelType>),
            NotInVec(Vec<super::super::ChannelType>),
            Not(super::super::ChannelType),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for ChannelTypeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum InteractionTypeFilter {
            Equals(super::super::InteractionType),
            InVec(Vec<super::super::InteractionType>),
            NotInVec(Vec<super::super::InteractionType>),
            Not(super::super::InteractionType),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for InteractionTypeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
    }
    pub mod write_params {
        #[derive(Debug, Clone)]
        pub enum BigIntParam {
            Set(i64),
            Increment(i64),
            Decrement(i64),
            Multiply(i64),
            Divide(i64),
        }
        impl Into<::prisma_client_rust::PrismaValue> for BigIntParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::BigInt(value),
                    Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum BigIntNullableParam {
            Set(Option<i64>),
            Increment(i64),
            Decrement(i64),
            Multiply(i64),
            Divide(i64),
        }
        impl Into<::prisma_client_rust::PrismaValue> for BigIntNullableParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => value
                        .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum BooleanParam {
            Set(bool),
        }
        impl Into<::prisma_client_rust::PrismaValue> for BooleanParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::Boolean(value),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum ChannelTypeParam {
            Set(super::super::ChannelType),
        }
        impl Into<::prisma_client_rust::PrismaValue> for ChannelTypeParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum DateTimeParam {
            Set(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        }
        impl Into<::prisma_client_rust::PrismaValue> for DateTimeParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::DateTime(value),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum InteractionTypeParam {
            Set(super::super::InteractionType),
        }
        impl Into<::prisma_client_rust::PrismaValue> for InteractionTypeParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum StringParam {
            Set(String),
        }
        impl Into<::prisma_client_rust::PrismaValue> for StringParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::String(value),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum StringNullableParam {
            Set(Option<String>),
        }
        impl Into<::prisma_client_rust::PrismaValue> for StringNullableParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                }
            }
        }
    }
}
pub mod user {
    use super::_prisma::*;
    pub const NAME: &str = "User";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(super::_prisma::read_filters::BigIntFilter),
        Username(super::_prisma::read_filters::StringFilter),
        Nickname(super::_prisma::read_filters::StringNullableFilter),
        RolesSome(Vec<super::role::WhereParam>),
        RolesEvery(Vec<super::role::WhereParam>),
        RolesNone(Vec<super::role::WhereParam>),
        Admin(super::_prisma::read_filters::BooleanFilter),
        Verified(super::_prisma::read_filters::BooleanFilter),
        Bot(super::_prisma::read_filters::BooleanFilter),
        MessagesSome(Vec<super::message::WhereParam>),
        MessagesEvery(Vec<super::message::WhereParam>),
        MessagesNone(Vec<super::message::WhereParam>),
        ImpersonatedMessagesSome(Vec<super::impersonated_message_data::WhereParam>),
        ImpersonatedMessagesEvery(Vec<super::impersonated_message_data::WhereParam>),
        ImpersonatedMessagesNone(Vec<super::impersonated_message_data::WhereParam>),
        InteractionsSome(Vec<super::interaction::WhereParam>),
        InteractionsEvery(Vec<super::interaction::WhereParam>),
        InteractionsNone(Vec<super::interaction::WhereParam>),
        SettingsIsNull,
        SettingsIs(Vec<super::user_settings_data::WhereParam>),
        SettingsIsNot(Vec<super::user_settings_data::WhereParam>),
        Removed(super::_prisma::read_filters::BooleanFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Username(value) => (username::NAME, value.into()),
                Self::Nickname(value) => (nickname::NAME, value.into()),
                Self::RolesSome(where_params) => (
                    roles::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RolesEvery(where_params) => (
                    roles::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RolesNone(where_params) => (
                    roles::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Admin(value) => (admin::NAME, value.into()),
                Self::Verified(value) => (verified::NAME, value.into()),
                Self::Bot(value) => (bot::NAME, value.into()),
                Self::MessagesSome(where_params) => (
                    messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessagesEvery(where_params) => (
                    messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessagesNone(where_params) => (
                    messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ImpersonatedMessagesSome(where_params) => (
                    impersonated_messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ImpersonatedMessagesEvery(where_params) => (
                    impersonated_messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ImpersonatedMessagesNone(where_params) => (
                    impersonated_messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InteractionsSome(where_params) => (
                    interactions::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InteractionsEvery(where_params) => (
                    interactions::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InteractionsNone(where_params) => (
                    interactions::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SettingsIsNull => (
                    settings::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::SettingsIs(where_params) => (
                    settings::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SettingsIsNot(where_params) => (
                    settings::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Removed(value) => (removed::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i64),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        Id(super::SortOrder),
        Username(super::SortOrder),
        Nickname(super::SortOrder),
        Admin(super::SortOrder),
        Verified(super::SortOrder),
        Bot(super::SortOrder),
        Removed(super::SortOrder),
        Roles(Vec<super::role::OrderByRelationAggregateParam>),
        Messages(Vec<super::message::OrderByRelationAggregateParam>),
        ImpersonatedMessages(Vec<super::impersonated_message_data::OrderByRelationAggregateParam>),
        Interactions(Vec<super::interaction::OrderByRelationAggregateParam>),
        Settings(Vec<super::user_settings_data::OrderByWithRelationParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(param) => ("id", param.into()),
                Self::Username(param) => ("username", param.into()),
                Self::Nickname(param) => ("nickname", param.into()),
                Self::Admin(param) => ("admin", param.into()),
                Self::Verified(param) => ("verified", param.into()),
                Self::Bot(param) => ("bot", param.into()),
                Self::Removed(param) => ("removed", param.into()),
                Self::Roles(param) => (
                    "roles",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::Messages(param) => (
                    "messages",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::ImpersonatedMessages(param) => (
                    "impersonated_messages",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::Interactions(param) => (
                    "interactions",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::Settings(param) => (
                    "settings",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByRelationAggregateParam {
        _Count(super::SortOrder),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::_Count(param) => ("_count", param.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {
        Roles(super::role::ManyArgs),
        Messages(super::message::ManyArgs),
        ImpersonatedMessages(super::impersonated_message_data::ManyArgs),
        Interactions(super::interaction::ManyArgs),
        Settings(super::user_settings_data::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Roles(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(
                        <super::role::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    );
                    ::prisma_client_rust::Selection::new(
                        roles::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Messages(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: message :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        messages::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::ImpersonatedMessages(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: impersonated_message_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        impersonated_messages::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Interactions(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: interaction :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        interactions::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Settings(args) => {
                    let mut selections = < super :: user_settings_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(settings::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Username(super::_prisma::write_params::StringParam),
        Nickname(super::_prisma::write_params::StringNullableParam),
        ConnectRoles(Vec<super::role::UniqueWhereParam>),
        DisconnectRoles(Vec<super::role::UniqueWhereParam>),
        SetRoles(Vec<super::role::UniqueWhereParam>),
        Admin(super::_prisma::write_params::BooleanParam),
        Verified(super::_prisma::write_params::BooleanParam),
        Bot(super::_prisma::write_params::BooleanParam),
        ConnectMessages(Vec<super::message::UniqueWhereParam>),
        DisconnectMessages(Vec<super::message::UniqueWhereParam>),
        SetMessages(Vec<super::message::UniqueWhereParam>),
        ConnectImpersonatedMessages(Vec<super::impersonated_message_data::UniqueWhereParam>),
        DisconnectImpersonatedMessages(Vec<super::impersonated_message_data::UniqueWhereParam>),
        SetImpersonatedMessages(Vec<super::impersonated_message_data::UniqueWhereParam>),
        ConnectInteractions(Vec<super::interaction::UniqueWhereParam>),
        DisconnectInteractions(Vec<super::interaction::UniqueWhereParam>),
        SetInteractions(Vec<super::interaction::UniqueWhereParam>),
        ConnectSettings(super::user_settings_data::UniqueWhereParam),
        DisconnectSettings,
        Removed(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => (id::NAME, value.into()),
                Self::Username(value) => (username::NAME, value.into()),
                Self::Nickname(value) => (nickname::NAME, value.into()),
                Self::ConnectRoles(where_params) => (
                    roles::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectRoles(where_params) => (
                    roles::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SetRoles(where_params) => (
                    roles::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::Admin(value) => (admin::NAME, value.into()),
                Self::Verified(value) => (verified::NAME, value.into()),
                Self::Bot(value) => (bot::NAME, value.into()),
                Self::ConnectMessages(where_params) => (
                    messages::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectMessages(where_params) => (
                    messages::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SetMessages(where_params) => (
                    messages::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ConnectImpersonatedMessages(where_params) => (
                    impersonated_messages::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectImpersonatedMessages(where_params) => (
                    impersonated_messages::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SetImpersonatedMessages(where_params) => (
                    impersonated_messages::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ConnectInteractions(where_params) => (
                    interactions::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectInteractions(where_params) => (
                    interactions::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SetInteractions(where_params) => (
                    interactions::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ConnectSettings(where_param) => (
                    settings::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectSettings => (
                    settings::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                Self::Removed(value) => (removed::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Username(super::_prisma::write_params::StringParam),
        Nickname(super::_prisma::write_params::StringNullableParam),
        Admin(super::_prisma::write_params::BooleanParam),
        Verified(super::_prisma::write_params::BooleanParam),
        Bot(super::_prisma::write_params::BooleanParam),
        Removed(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => ("id", value.into()),
                Self::Username(value) => ("username", value.into()),
                Self::Nickname(value) => ("nickname", value.into()),
                Self::Admin(value) => ("admin", value.into()),
                Self::Verified(value) => ("verified", value.into()),
                Self::Bot(value) => ("bot", value.into()),
                Self::Removed(value) => ("removed", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_user,
        select,
        generated::user,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "username")]
            username: username::Type,
            #[serde(rename = "nickname")]
            nickname: nickname::Type,
            #[serde(rename = "roles")]
            roles: roles::Type,
            #[serde(rename = "admin")]
            admin: admin::Type,
            #[serde(rename = "verified")]
            verified: verified::Type,
            #[serde(rename = "bot")]
            bot: bot::Type,
            #[serde(rename = "messages")]
            messages: messages::Type,
            #[serde(rename = "impersonated_messages")]
            impersonated_messages: impersonated_messages::Type,
            #[serde(rename = "interactions")]
            interactions: interactions::Type,
            #[serde(rename = "settings")]
            settings: settings::Type,
            #[serde(rename = "removed")]
            removed: removed::Type,
        },
        [
            (id, Scalar),
            (username, Scalar),
            (nickname, Scalar),
            (roles, Relation(generated::role, Many)),
            (admin, Scalar),
            (verified, Scalar),
            (bot, Scalar),
            (messages, Relation(generated::message, Many)),
            (
                impersonated_messages,
                Relation(generated::impersonated_message_data, Many)
            ),
            (interactions, Relation(generated::interaction, Many)),
            (settings, Relation(generated::user_settings_data, One)),
            (removed, Scalar)
        ]
    );
    pub enum SelectParam {
        Id(id::Select),
        Username(username::Select),
        Nickname(nickname::Select),
        Roles(roles::Select),
        Admin(admin::Select),
        Verified(verified::Select),
        Bot(bot::Select),
        Messages(messages::Select),
        ImpersonatedMessages(impersonated_messages::Select),
        Interactions(interactions::Select),
        Settings(settings::Select),
        Removed(removed::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Username(data) => data.into(),
                Self::Nickname(data) => data.into(),
                Self::Roles(data) => data.into(),
                Self::Admin(data) => data.into(),
                Self::Verified(data) => data.into(),
                Self::Bot(data) => data.into(),
                Self::Messages(data) => data.into(),
                Self::ImpersonatedMessages(data) => data.into(),
                Self::Interactions(data) => data.into(),
                Self::Settings(data) => data.into(),
                Self::Removed(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_user,
        include,
        generated::user,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "username")]
            username: username::Type,
            #[serde(rename = "nickname")]
            nickname: nickname::Type,
            #[serde(rename = "roles")]
            roles: roles::Type,
            #[serde(rename = "admin")]
            admin: admin::Type,
            #[serde(rename = "verified")]
            verified: verified::Type,
            #[serde(rename = "bot")]
            bot: bot::Type,
            #[serde(rename = "messages")]
            messages: messages::Type,
            #[serde(rename = "impersonated_messages")]
            impersonated_messages: impersonated_messages::Type,
            #[serde(rename = "interactions")]
            interactions: interactions::Type,
            #[serde(rename = "settings")]
            settings: settings::Type,
            #[serde(rename = "removed")]
            removed: removed::Type,
        },
        [
            (roles, Relation(generated::role, Many)),
            (messages, Relation(generated::message, Many)),
            (
                impersonated_messages,
                Relation(generated::impersonated_message_data, Many)
            ),
            (interactions, Relation(generated::interaction, Many)),
            (settings, Relation(generated::user_settings_data, One))
        ]
    );
    pub enum IncludeParam {
        Id(id::Include),
        Username(username::Include),
        Nickname(nickname::Include),
        Roles(roles::Include),
        Admin(admin::Include),
        Verified(verified::Include),
        Bot(bot::Include),
        Messages(messages::Include),
        ImpersonatedMessages(impersonated_messages::Include),
        Interactions(interactions::Include),
        Settings(settings::Include),
        Removed(removed::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Username(data) => data.into(),
                Self::Nickname(data) => data.into(),
                Self::Roles(data) => data.into(),
                Self::Admin(data) => data.into(),
                Self::Verified(data) => data.into(),
                Self::Bot(data) => data.into(),
                Self::Messages(data) => data.into(),
                Self::ImpersonatedMessages(data) => data.into(),
                Self::Interactions(data) => data.into(),
                Self::Settings(data) => data.into(),
                Self::Removed(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub id: i64,
        pub username: String,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client.user().create(self.id, self.username, self._params)
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params
                .extend([id::set(self.id), username::set(self.username)]);
            self._params
        }
    }
    pub fn create(id: i64, username: String, _params: Vec<SetParam>) -> Create {
        Create {
            id,
            username,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub id: i64,
        pub username: String,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client
                .user()
                .create_unchecked(self.id, self.username, self._params)
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params
                .extend([id::set(self.id), username::set(self.username)]);
            self._params
        }
    }
    pub fn create_unchecked(
        id: i64,
        username: String,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            id,
            username,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(username::NAME),
                ::prisma_client_rust::sel(nickname::NAME),
                ::prisma_client_rust::sel(admin::NAME),
                ::prisma_client_rust::sel(verified::NAME),
                ::prisma_client_rust::sel(bot::NAME),
                ::prisma_client_rust::sel(removed::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: id::Type,
        #[serde(rename = "username")]
        pub username: username::Type,
        #[serde(rename = "nickname")]
        pub nickname: nickname::Type,
        #[serde(rename = "roles")]
        pub roles: Option<roles::RecursiveSafeType>,
        #[serde(rename = "admin")]
        pub admin: admin::Type,
        #[serde(rename = "verified")]
        pub verified: verified::Type,
        #[serde(rename = "bot")]
        pub bot: bot::Type,
        #[serde(rename = "messages")]
        pub messages: Option<messages::RecursiveSafeType>,
        #[serde(rename = "impersonated_messages")]
        pub impersonated_messages: Option<impersonated_messages::RecursiveSafeType>,
        #[serde(rename = "interactions")]
        pub interactions: Option<interactions::RecursiveSafeType>,
        #[serde(
            rename = "settings",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub settings: Option<settings::RecursiveSafeType>,
        #[serde(rename = "removed")]
        pub removed: removed::Type,
    }
    impl Data {
        pub fn roles(&self) -> Result<&roles::Type, ::prisma_client_rust::RelationNotFetchedError> {
            self.roles
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(roles),
                ))
        }
        pub fn messages(
            &self,
        ) -> Result<&messages::Type, ::prisma_client_rust::RelationNotFetchedError> {
            self.messages
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(messages),
                ))
        }
        pub fn impersonated_messages(
            &self,
        ) -> Result<&impersonated_messages::Type, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.impersonated_messages.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    impersonated_messages
                )),
            )
        }
        pub fn interactions(
            &self,
        ) -> Result<&interactions::Type, ::prisma_client_rust::RelationNotFetchedError> {
            self.interactions
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(interactions),
                ))
        }
        pub fn settings(
            &self,
        ) -> Result<
            Option<&super::user_settings_data::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.settings
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(settings),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_user,
        generated::user,
        struct Data {
            #[serde(rename = "id")]
            pub id: generated::user::id::Type,
            #[serde(rename = "username")]
            pub username: generated::user::username::Type,
            #[serde(rename = "nickname")]
            #[serde(default, with = "::prisma_client_rust::serde::double_option")]
            pub nickname: generated::user::nickname::Type,
            #[serde(rename = "admin")]
            pub admin: generated::user::admin::Type,
            #[serde(rename = "verified")]
            pub verified: generated::user::verified::Type,
            #[serde(rename = "bot")]
            pub bot: generated::user::bot::Type,
            #[serde(rename = "removed")]
            pub removed: generated::user::removed::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _user_filter,
        generated::user,
        [
            (id, Scalar),
            (username, Scalar),
            (nickname, Scalar),
            (roles, Relation(generated::role, Many)),
            (admin, Scalar),
            (verified, Scalar),
            (bot, Scalar),
            (messages, Relation(generated::message, Many)),
            (
                impersonated_messages,
                Relation(generated::impersonated_message_data, Many)
            ),
            (interactions, Relation(generated::interaction, Many)),
            (settings, Relation(generated::user_settings_data, One)),
            (removed, Scalar)
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            id: impl Into<i64>,
            username: impl Into<String>,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            let id = id.into();
            let username = username.into();
            _params.extend([id::set(id), username::set(username)]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: impl Into<i64>,
            username: impl Into<String>,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            let id = id.into();
            let username = username.into();
            _params.extend([id::set(id), username::set(username)]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod _count {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "_count";
        pub struct Order(super::SortOrder);
        pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByRelationAggregateParam {
            fn from(Order(v): Order) -> Self {
                Self::_Count(v)
            }
        }
    }
    pub mod admin {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "admin";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Admin(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            Admin,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Admin(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Admin(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Admin(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Admin(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Admin(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Admin(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Admin(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod bot {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "bot";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Bot(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BooleanFilter, Bot, {
            fn not(_: bool) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Bot(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Bot(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Bot(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Bot(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Bot(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Bot(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Bot(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::IdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Id(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Id, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Id(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod impersonated_messages {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "impersonated_messages";
        pub type Type = Vec<impersonated_message_data::Data>;
        pub type RecursiveSafeType = Type;
        pub fn some(value: Vec<impersonated_message_data::WhereParam>) -> WhereParam {
            WhereParam::ImpersonatedMessagesSome(value)
        }
        pub fn every(value: Vec<impersonated_message_data::WhereParam>) -> WhereParam {
            WhereParam::ImpersonatedMessagesEvery(value)
        }
        pub fn none(value: Vec<impersonated_message_data::WhereParam>) -> WhereParam {
            WhereParam::ImpersonatedMessagesNone(value)
        }
        pub struct Order(Vec<impersonated_message_data::OrderByRelationAggregateParam>);
        pub fn order<T: From<Order>>(
            v: Vec<impersonated_message_data::OrderByRelationAggregateParam>,
        ) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::ImpersonatedMessages(v)
            }
        }
        pub struct Fetch(pub impersonated_message_data::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<impersonated_message_data::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(
                mut self,
                param: impersonated_message_data::OrderByWithRelationParam,
            ) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: impersonated_message_data::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ImpersonatedMessages(v)
            }
        }
        pub fn fetch(params: Vec<impersonated_message_data::WhereParam>) -> Fetch {
            Fetch(impersonated_message_data::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<impersonated_message_data::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectImpersonatedMessages(v)
            }
        }
        pub fn connect<T: From<Connect>>(
            params: Vec<impersonated_message_data::UniqueWhereParam>,
        ) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<impersonated_message_data::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectImpersonatedMessages(params)
        }
        pub fn set(params: Vec<impersonated_message_data::UniqueWhereParam>) -> SetParam {
            SetParam::SetImpersonatedMessages(params)
        }
        pub enum Select {
            Select(
                impersonated_message_data::ManyArgs,
                Vec<impersonated_message_data::SelectParam>,
            ),
            Include(
                impersonated_message_data::ManyArgs,
                Vec<impersonated_message_data::IncludeParam>,
            ),
            Fetch(impersonated_message_data::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ImpersonatedMessages(self)
            }
        }
        impl Select {
            pub fn select(
                args: impersonated_message_data::ManyArgs,
                nested_selections: Vec<impersonated_message_data::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: impersonated_message_data::ManyArgs,
                nested_selections: Vec<impersonated_message_data::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < impersonated_message_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
        pub enum Include {
            Select(
                impersonated_message_data::ManyArgs,
                Vec<impersonated_message_data::SelectParam>,
            ),
            Include(
                impersonated_message_data::ManyArgs,
                Vec<impersonated_message_data::IncludeParam>,
            ),
            Fetch(impersonated_message_data::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ImpersonatedMessages(self)
            }
        }
        impl Include {
            pub fn select(
                args: impersonated_message_data::ManyArgs,
                nested_selections: Vec<impersonated_message_data::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: impersonated_message_data::ManyArgs,
                nested_selections: Vec<impersonated_message_data::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < impersonated_message_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < impersonated_message_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
    }
    pub mod interactions {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "interactions";
        pub type Type = Vec<interaction::Data>;
        pub type RecursiveSafeType = Type;
        pub fn some(value: Vec<interaction::WhereParam>) -> WhereParam {
            WhereParam::InteractionsSome(value)
        }
        pub fn every(value: Vec<interaction::WhereParam>) -> WhereParam {
            WhereParam::InteractionsEvery(value)
        }
        pub fn none(value: Vec<interaction::WhereParam>) -> WhereParam {
            WhereParam::InteractionsNone(value)
        }
        pub struct Order(Vec<interaction::OrderByRelationAggregateParam>);
        pub fn order<T: From<Order>>(v: Vec<interaction::OrderByRelationAggregateParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Interactions(v)
            }
        }
        pub struct Fetch(pub interaction::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<interaction::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: interaction::OrderByWithRelationParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: interaction::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Interactions(v)
            }
        }
        pub fn fetch(params: Vec<interaction::WhereParam>) -> Fetch {
            Fetch(interaction::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<interaction::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectInteractions(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<interaction::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<interaction::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectInteractions(params)
        }
        pub fn set(params: Vec<interaction::UniqueWhereParam>) -> SetParam {
            SetParam::SetInteractions(params)
        }
        pub enum Select {
            Select(interaction::ManyArgs, Vec<interaction::SelectParam>),
            Include(interaction::ManyArgs, Vec<interaction::IncludeParam>),
            Fetch(interaction::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Interactions(self)
            }
        }
        impl Select {
            pub fn select(
                args: interaction::ManyArgs,
                nested_selections: Vec<interaction::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: interaction::ManyArgs,
                nested_selections: Vec<interaction::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <interaction::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
        pub enum Include {
            Select(interaction::ManyArgs, Vec<interaction::SelectParam>),
            Include(interaction::ManyArgs, Vec<interaction::IncludeParam>),
            Fetch(interaction::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Interactions(self)
            }
        }
        impl Include {
            pub fn select(
                args: interaction::ManyArgs,
                nested_selections: Vec<interaction::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: interaction::ManyArgs,
                nested_selections: Vec<interaction::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < interaction :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <interaction::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
    }
    pub mod messages {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "messages";
        pub type Type = Vec<message::Data>;
        pub type RecursiveSafeType = Type;
        pub fn some(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessagesSome(value)
        }
        pub fn every(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessagesEvery(value)
        }
        pub fn none(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessagesNone(value)
        }
        pub struct Order(Vec<message::OrderByRelationAggregateParam>);
        pub fn order<T: From<Order>>(v: Vec<message::OrderByRelationAggregateParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Messages(v)
            }
        }
        pub struct Fetch(pub message::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<message::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: message::OrderByWithRelationParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: message::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Messages(v)
            }
        }
        pub fn fetch(params: Vec<message::WhereParam>) -> Fetch {
            Fetch(message::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<message::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectMessages(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<message::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<message::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectMessages(params)
        }
        pub fn set(params: Vec<message::UniqueWhereParam>) -> SetParam {
            SetParam::SetMessages(params)
        }
        pub enum Select {
            Select(message::ManyArgs, Vec<message::SelectParam>),
            Include(message::ManyArgs, Vec<message::IncludeParam>),
            Fetch(message::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Messages(self)
            }
        }
        impl Select {
            pub fn select(
                args: message::ManyArgs,
                nested_selections: Vec<message::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: message::ManyArgs,
                nested_selections: Vec<message::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
        pub enum Include {
            Select(message::ManyArgs, Vec<message::SelectParam>),
            Include(message::ManyArgs, Vec<message::IncludeParam>),
            Fetch(message::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Messages(self)
            }
        }
        impl Include {
            pub fn select(
                args: message::ManyArgs,
                nested_selections: Vec<message::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: message::ManyArgs,
                nested_selections: Vec<message::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => {
                        (args.to_graphql().0, {
                            let mut nested_selections = < message :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                            nested_selections.extend(selections.into_iter().map(Into::into));
                            nested_selections
                        })
                    }
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
    }
    pub mod nickname {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "nickname";
        pub type Type = Option<String>;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Option<String>);
        pub fn equals<T: From<Equals>>(value: impl Into<Option<String>>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Nickname(_prisma::read_filters::StringNullableFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Nickname,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Nickname(v)
            }
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Nickname(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<Option<String>>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Nickname(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Nickname(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Nickname(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Nickname(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Nickname(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod removed {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "removed";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Removed(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            Removed,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Removed(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Removed(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Removed(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Removed(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Removed(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Removed(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Removed(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod roles {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "roles";
        pub type Type = Vec<role::Data>;
        pub type RecursiveSafeType = Type;
        pub fn some(value: Vec<role::WhereParam>) -> WhereParam {
            WhereParam::RolesSome(value)
        }
        pub fn every(value: Vec<role::WhereParam>) -> WhereParam {
            WhereParam::RolesEvery(value)
        }
        pub fn none(value: Vec<role::WhereParam>) -> WhereParam {
            WhereParam::RolesNone(value)
        }
        pub struct Order(Vec<role::OrderByRelationAggregateParam>);
        pub fn order<T: From<Order>>(v: Vec<role::OrderByRelationAggregateParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Roles(v)
            }
        }
        pub struct Fetch(pub role::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<role::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: role::OrderByWithRelationParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: role::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Roles(v)
            }
        }
        pub fn fetch(params: Vec<role::WhereParam>) -> Fetch {
            Fetch(role::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<role::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectRoles(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<role::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<role::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectRoles(params)
        }
        pub fn set(params: Vec<role::UniqueWhereParam>) -> SetParam {
            SetParam::SetRoles(params)
        }
        pub enum Select {
            Select(role::ManyArgs, Vec<role::SelectParam>),
            Include(role::ManyArgs, Vec<role::IncludeParam>),
            Fetch(role::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Roles(self)
            }
        }
        impl Select {
            pub fn select(args: role::ManyArgs, nested_selections: Vec<role::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: role::ManyArgs,
                nested_selections: Vec<role::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <role::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
        pub enum Include {
            Select(role::ManyArgs, Vec<role::SelectParam>),
            Include(role::ManyArgs, Vec<role::IncludeParam>),
            Fetch(role::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Roles(self)
            }
        }
        impl Include {
            pub fn select(args: role::ManyArgs, nested_selections: Vec<role::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: role::ManyArgs,
                nested_selections: Vec<role::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <role::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <role::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
    }
    pub mod settings {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "settings";
        pub type Type = Option<user_settings_data::Data>;
        pub type RecursiveSafeType = Option<Box<user_settings_data::Data>>;
        pub fn is(value: Vec<user_settings_data::WhereParam>) -> WhereParam {
            WhereParam::SettingsIs(value)
        }
        pub fn is_not(value: Vec<user_settings_data::WhereParam>) -> WhereParam {
            WhereParam::SettingsIsNot(value)
        }
        pub struct Order(Vec<user_settings_data::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<user_settings_data::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Settings(v)
            }
        }
        pub struct Fetch(pub user_settings_data::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user_settings_data::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Settings(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user_settings_data::UniqueArgs::new())
        }
        pub struct Connect(user_settings_data::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSettings(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user_settings_data::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectSettings
        }
        pub fn is_null() -> WhereParam {
            WhereParam::SettingsIsNull
        }
        pub enum Select {
            Select(Vec<user_settings_data::SelectParam>),
            Include(Vec<user_settings_data::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Settings(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<user_settings_data::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user_settings_data::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < user_settings_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("settings", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<user_settings_data::SelectParam>),
            Include(Vec<user_settings_data::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Settings(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<user_settings_data::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user_settings_data::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < user_settings_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < user_settings_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("settings", None, [], selections)
            }
        }
    }
    pub mod username {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "username";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: impl Into<String>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Username(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Username,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Username(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Username(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<String>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Username(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Username(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Username(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Username(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Username(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod verified {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "verified";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Verified(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            Verified,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Verified(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Verified(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Verified(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Verified(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Verified(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Verified(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Verified(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
pub mod role {
    use super::_prisma::*;
    pub const NAME: &str = "Role";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(super::_prisma::read_filters::BigIntFilter),
        Name(super::_prisma::read_filters::StringFilter),
        Color(super::_prisma::read_filters::StringFilter),
        UsersSome(Vec<super::user::WhereParam>),
        UsersEvery(Vec<super::user::WhereParam>),
        UsersNone(Vec<super::user::WhereParam>),
        ColorRole(super::_prisma::read_filters::BooleanFilter),
        Deleted(super::_prisma::read_filters::BooleanFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Color(value) => (color::NAME, value.into()),
                Self::UsersSome(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersEvery(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersNone(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ColorRole(value) => (color_role::NAME, value.into()),
                Self::Deleted(value) => (deleted::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i64),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        Id(super::SortOrder),
        Name(super::SortOrder),
        Color(super::SortOrder),
        ColorRole(super::SortOrder),
        Deleted(super::SortOrder),
        Users(Vec<super::user::OrderByRelationAggregateParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(param) => ("id", param.into()),
                Self::Name(param) => ("name", param.into()),
                Self::Color(param) => ("color", param.into()),
                Self::ColorRole(param) => ("color_role", param.into()),
                Self::Deleted(param) => ("deleted", param.into()),
                Self::Users(param) => (
                    "users",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByRelationAggregateParam {
        _Count(super::SortOrder),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::_Count(param) => ("_count", param.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {
        Users(super::user::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Users(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    );
                    ::prisma_client_rust::Selection::new(
                        users::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Name(super::_prisma::write_params::StringParam),
        Color(super::_prisma::write_params::StringParam),
        ConnectUsers(Vec<super::user::UniqueWhereParam>),
        DisconnectUsers(Vec<super::user::UniqueWhereParam>),
        SetUsers(Vec<super::user::UniqueWhereParam>),
        ColorRole(super::_prisma::write_params::BooleanParam),
        Deleted(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Color(value) => (color::NAME, value.into()),
                Self::ConnectUsers(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectUsers(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SetUsers(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ColorRole(value) => (color_role::NAME, value.into()),
                Self::Deleted(value) => (deleted::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Name(super::_prisma::write_params::StringParam),
        Color(super::_prisma::write_params::StringParam),
        ColorRole(super::_prisma::write_params::BooleanParam),
        Deleted(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => ("id", value.into()),
                Self::Name(value) => ("name", value.into()),
                Self::Color(value) => ("color", value.into()),
                Self::ColorRole(value) => ("color_role", value.into()),
                Self::Deleted(value) => ("deleted", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_role,
        select,
        generated::role,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "name")]
            name: name::Type,
            #[serde(rename = "color")]
            color: color::Type,
            #[serde(rename = "users")]
            users: users::Type,
            #[serde(rename = "color_role")]
            color_role: color_role::Type,
            #[serde(rename = "deleted")]
            deleted: deleted::Type,
        },
        [
            (id, Scalar),
            (name, Scalar),
            (color, Scalar),
            (users, Relation(generated::user, Many)),
            (color_role, Scalar),
            (deleted, Scalar)
        ]
    );
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Color(color::Select),
        Users(users::Select),
        ColorRole(color_role::Select),
        Deleted(deleted::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Name(data) => data.into(),
                Self::Color(data) => data.into(),
                Self::Users(data) => data.into(),
                Self::ColorRole(data) => data.into(),
                Self::Deleted(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_role,
        include,
        generated::role,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "name")]
            name: name::Type,
            #[serde(rename = "color")]
            color: color::Type,
            #[serde(rename = "users")]
            users: users::Type,
            #[serde(rename = "color_role")]
            color_role: color_role::Type,
            #[serde(rename = "deleted")]
            deleted: deleted::Type,
        },
        [(users, Relation(generated::user, Many))]
    );
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Color(color::Include),
        Users(users::Include),
        ColorRole(color_role::Include),
        Deleted(deleted::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Name(data) => data.into(),
                Self::Color(data) => data.into(),
                Self::Users(data) => data.into(),
                Self::ColorRole(data) => data.into(),
                Self::Deleted(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub id: i64,
        pub name: String,
        pub color: String,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client
                .role()
                .create(self.id, self.name, self.color, self._params)
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([
                id::set(self.id),
                name::set(self.name),
                color::set(self.color),
            ]);
            self._params
        }
    }
    pub fn create(id: i64, name: String, color: String, _params: Vec<SetParam>) -> Create {
        Create {
            id,
            name,
            color,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub id: i64,
        pub name: String,
        pub color: String,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client
                .role()
                .create_unchecked(self.id, self.name, self.color, self._params)
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([
                id::set(self.id),
                name::set(self.name),
                color::set(self.color),
            ]);
            self._params
        }
    }
    pub fn create_unchecked(
        id: i64,
        name: String,
        color: String,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            id,
            name,
            color,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(color::NAME),
                ::prisma_client_rust::sel(color_role::NAME),
                ::prisma_client_rust::sel(deleted::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: id::Type,
        #[serde(rename = "name")]
        pub name: name::Type,
        #[serde(rename = "color")]
        pub color: color::Type,
        #[serde(rename = "users")]
        pub users: Option<users::RecursiveSafeType>,
        #[serde(rename = "color_role")]
        pub color_role: color_role::Type,
        #[serde(rename = "deleted")]
        pub deleted: deleted::Type,
    }
    impl Data {
        pub fn users(&self) -> Result<&users::Type, ::prisma_client_rust::RelationNotFetchedError> {
            self.users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users),
                ))
        }
    }
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_role,
        generated::role,
        struct Data {
            #[serde(rename = "id")]
            pub id: generated::role::id::Type,
            #[serde(rename = "name")]
            pub name: generated::role::name::Type,
            #[serde(rename = "color")]
            pub color: generated::role::color::Type,
            #[serde(rename = "color_role")]
            pub color_role: generated::role::color_role::Type,
            #[serde(rename = "deleted")]
            pub deleted: generated::role::deleted::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _role_filter,
        generated::role,
        [
            (id, Scalar),
            (name, Scalar),
            (color, Scalar),
            (users, Relation(generated::user, Many)),
            (color_role, Scalar),
            (deleted, Scalar)
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            id: impl Into<i64>,
            name: impl Into<String>,
            color: impl Into<String>,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            let id = id.into();
            let name = name.into();
            let color = color.into();
            _params.extend([id::set(id), name::set(name), color::set(color)]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: impl Into<i64>,
            name: impl Into<String>,
            color: impl Into<String>,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            let id = id.into();
            let name = name.into();
            let color = color.into();
            _params.extend([id::set(id), name::set(name), color::set(color)]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod _count {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "_count";
        pub struct Order(super::SortOrder);
        pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByRelationAggregateParam {
            fn from(Order(v): Order) -> Self {
                Self::_Count(v)
            }
        }
    }
    pub mod color {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "color";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: impl Into<String>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Color(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Color,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Color(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Color(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<String>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Color(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Color(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Color(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Color(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Color(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod color_role {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "color_role";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::ColorRole(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            ColorRole,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::ColorRole(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::ColorRole(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ColorRole(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ColorRole(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ColorRole(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ColorRole(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ColorRole(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod deleted {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "deleted";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Deleted(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            Deleted,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Deleted(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Deleted(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Deleted(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Deleted(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Deleted(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Deleted(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Deleted(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::IdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Id(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Id, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Id(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "name";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: impl Into<String>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Name(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Name(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<String>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Name(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Name(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod users {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "users";
        pub type Type = Vec<user::Data>;
        pub type RecursiveSafeType = Type;
        pub fn some(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UsersSome(value)
        }
        pub fn every(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UsersEvery(value)
        }
        pub fn none(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UsersNone(value)
        }
        pub struct Order(Vec<user::OrderByRelationAggregateParam>);
        pub fn order<T: From<Order>>(v: Vec<user::OrderByRelationAggregateParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Users(v)
            }
        }
        pub struct Fetch(pub user::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: user::OrderByWithRelationParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: user::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Users(v)
            }
        }
        pub fn fetch(params: Vec<user::WhereParam>) -> Fetch {
            Fetch(user::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<user::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<user::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<user::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectUsers(params)
        }
        pub fn set(params: Vec<user::UniqueWhereParam>) -> SetParam {
            SetParam::SetUsers(params)
        }
        pub enum Select {
            Select(user::ManyArgs, Vec<user::SelectParam>),
            Include(user::ManyArgs, Vec<user::IncludeParam>),
            Fetch(user::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Users(self)
            }
        }
        impl Select {
            pub fn select(args: user::ManyArgs, nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user::ManyArgs,
                nested_selections: Vec<user::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
        pub enum Include {
            Select(user::ManyArgs, Vec<user::SelectParam>),
            Include(user::ManyArgs, Vec<user::IncludeParam>),
            Fetch(user::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Users(self)
            }
        }
        impl Include {
            pub fn select(args: user::ManyArgs, nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user::ManyArgs,
                nested_selections: Vec<user::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
    }
}
pub mod attachment {
    use super::_prisma::*;
    pub const NAME: &str = "Attachment";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(super::_prisma::read_filters::BigIntFilter),
        Filename(super::_prisma::read_filters::StringFilter),
        Url(super::_prisma::read_filters::StringFilter),
        SizeBytes(super::_prisma::read_filters::BigIntFilter),
        MessageIs(Vec<super::message::WhereParam>),
        MessageIsNot(Vec<super::message::WhereParam>),
        MessageId(super::_prisma::read_filters::BigIntFilter),
        Deleted(super::_prisma::read_filters::BooleanFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Filename(value) => (filename::NAME, value.into()),
                Self::Url(value) => (url::NAME, value.into()),
                Self::SizeBytes(value) => (size_bytes::NAME, value.into()),
                Self::MessageIs(where_params) => (
                    message::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessageIsNot(where_params) => (
                    message::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessageId(value) => (message_id::NAME, value.into()),
                Self::Deleted(value) => (deleted::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i64),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        Id(super::SortOrder),
        Filename(super::SortOrder),
        Url(super::SortOrder),
        SizeBytes(super::SortOrder),
        MessageId(super::SortOrder),
        Deleted(super::SortOrder),
        Message(Vec<super::message::OrderByWithRelationParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(param) => ("id", param.into()),
                Self::Filename(param) => ("filename", param.into()),
                Self::Url(param) => ("url", param.into()),
                Self::SizeBytes(param) => ("size_bytes", param.into()),
                Self::MessageId(param) => ("message_id", param.into()),
                Self::Deleted(param) => ("deleted", param.into()),
                Self::Message(param) => (
                    "message",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByRelationAggregateParam {
        _Count(super::SortOrder),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::_Count(param) => ("_count", param.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {
        Message(super::message::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Message(args) => {
                    let mut selections = < super :: message :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(message::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Filename(super::_prisma::write_params::StringParam),
        Url(super::_prisma::write_params::StringParam),
        SizeBytes(super::_prisma::write_params::BigIntParam),
        ConnectMessage(super::message::UniqueWhereParam),
        MessageId(super::_prisma::write_params::BigIntParam),
        Deleted(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => (id::NAME, value.into()),
                Self::Filename(value) => (filename::NAME, value.into()),
                Self::Url(value) => (url::NAME, value.into()),
                Self::SizeBytes(value) => (size_bytes::NAME, value.into()),
                Self::ConnectMessage(where_param) => (
                    message::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessageId(value) => (message_id::NAME, value.into()),
                Self::Deleted(value) => (deleted::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Filename(super::_prisma::write_params::StringParam),
        Url(super::_prisma::write_params::StringParam),
        SizeBytes(super::_prisma::write_params::BigIntParam),
        MessageId(super::_prisma::write_params::BigIntParam),
        Deleted(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => ("id", value.into()),
                Self::Filename(value) => ("filename", value.into()),
                Self::Url(value) => ("url", value.into()),
                Self::SizeBytes(value) => ("size_bytes", value.into()),
                Self::MessageId(value) => ("message_id", value.into()),
                Self::Deleted(value) => ("deleted", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_attachment,
        select,
        generated::attachment,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "filename")]
            filename: filename::Type,
            #[serde(rename = "url")]
            url: url::Type,
            #[serde(rename = "size_bytes")]
            size_bytes: size_bytes::Type,
            #[serde(rename = "message")]
            message: message::Type,
            #[serde(rename = "message_id")]
            message_id: message_id::Type,
            #[serde(rename = "deleted")]
            deleted: deleted::Type,
        },
        [
            (id, Scalar),
            (filename, Scalar),
            (url, Scalar),
            (size_bytes, Scalar),
            (message, Relation(generated::message, One)),
            (message_id, Scalar),
            (deleted, Scalar)
        ]
    );
    pub enum SelectParam {
        Id(id::Select),
        Filename(filename::Select),
        Url(url::Select),
        SizeBytes(size_bytes::Select),
        Message(message::Select),
        MessageId(message_id::Select),
        Deleted(deleted::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Filename(data) => data.into(),
                Self::Url(data) => data.into(),
                Self::SizeBytes(data) => data.into(),
                Self::Message(data) => data.into(),
                Self::MessageId(data) => data.into(),
                Self::Deleted(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_attachment,
        include,
        generated::attachment,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "filename")]
            filename: filename::Type,
            #[serde(rename = "url")]
            url: url::Type,
            #[serde(rename = "size_bytes")]
            size_bytes: size_bytes::Type,
            #[serde(rename = "message")]
            message: message::Type,
            #[serde(rename = "message_id")]
            message_id: message_id::Type,
            #[serde(rename = "deleted")]
            deleted: deleted::Type,
        },
        [(message, Relation(generated::message, One))]
    );
    pub enum IncludeParam {
        Id(id::Include),
        Filename(filename::Include),
        Url(url::Include),
        SizeBytes(size_bytes::Include),
        Message(message::Include),
        MessageId(message_id::Include),
        Deleted(deleted::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Filename(data) => data.into(),
                Self::Url(data) => data.into(),
                Self::SizeBytes(data) => data.into(),
                Self::Message(data) => data.into(),
                Self::MessageId(data) => data.into(),
                Self::Deleted(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub id: i64,
        pub filename: String,
        pub url: String,
        pub size_bytes: i64,
        pub message: super::message::UniqueWhereParam,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client.attachment().create(
                self.id,
                self.filename,
                self.url,
                self.size_bytes,
                self.message,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([
                id::set(self.id),
                filename::set(self.filename),
                url::set(self.url),
                size_bytes::set(self.size_bytes),
                message::connect(self.message),
            ]);
            self._params
        }
    }
    pub fn create(
        id: i64,
        filename: String,
        url: String,
        size_bytes: i64,
        message: super::message::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> Create {
        Create {
            id,
            filename,
            url,
            size_bytes,
            message,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub id: i64,
        pub filename: String,
        pub url: String,
        pub size_bytes: i64,
        pub message_id: i64,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client.attachment().create_unchecked(
                self.id,
                self.filename,
                self.url,
                self.size_bytes,
                self.message_id,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([
                id::set(self.id),
                filename::set(self.filename),
                url::set(self.url),
                size_bytes::set(self.size_bytes),
                message_id::set(self.message_id),
            ]);
            self._params
        }
    }
    pub fn create_unchecked(
        id: i64,
        filename: String,
        url: String,
        size_bytes: i64,
        message_id: i64,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            id,
            filename,
            url,
            size_bytes,
            message_id,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(filename::NAME),
                ::prisma_client_rust::sel(url::NAME),
                ::prisma_client_rust::sel(size_bytes::NAME),
                ::prisma_client_rust::sel(message_id::NAME),
                ::prisma_client_rust::sel(deleted::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: id::Type,
        #[serde(rename = "filename")]
        pub filename: filename::Type,
        #[serde(rename = "url")]
        pub url: url::Type,
        #[serde(rename = "size_bytes")]
        pub size_bytes: size_bytes::Type,
        #[serde(rename = "message")]
        pub message: Option<message::RecursiveSafeType>,
        #[serde(rename = "message_id")]
        pub message_id: message_id::Type,
        #[serde(rename = "deleted")]
        pub deleted: deleted::Type,
    }
    impl Data {
        pub fn message(
            &self,
        ) -> Result<&super::message::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.message
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(message),
                ))
                .map(|v| v.as_ref())
        }
    }
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_attachment,
        generated::attachment,
        struct Data {
            #[serde(rename = "id")]
            pub id: generated::attachment::id::Type,
            #[serde(rename = "filename")]
            pub filename: generated::attachment::filename::Type,
            #[serde(rename = "url")]
            pub url: generated::attachment::url::Type,
            #[serde(rename = "size_bytes")]
            pub size_bytes: generated::attachment::size_bytes::Type,
            #[serde(rename = "message_id")]
            pub message_id: generated::attachment::message_id::Type,
            #[serde(rename = "deleted")]
            pub deleted: generated::attachment::deleted::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _attachment_filter,
        generated::attachment,
        [
            (id, Scalar),
            (filename, Scalar),
            (url, Scalar),
            (size_bytes, Scalar),
            (message, Relation(generated::message, One)),
            (message_id, Scalar),
            (deleted, Scalar)
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            id: impl Into<i64>,
            filename: impl Into<String>,
            url: impl Into<String>,
            size_bytes: impl Into<i64>,
            message: super::message::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            let id = id.into();
            let filename = filename.into();
            let url = url.into();
            let size_bytes = size_bytes.into();
            let message = message.into();
            _params.extend([
                id::set(id),
                filename::set(filename),
                url::set(url),
                size_bytes::set(size_bytes),
                message::connect(message),
            ]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: impl Into<i64>,
            filename: impl Into<String>,
            url: impl Into<String>,
            size_bytes: impl Into<i64>,
            message_id: impl Into<i64>,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            let id = id.into();
            let filename = filename.into();
            let url = url.into();
            let size_bytes = size_bytes.into();
            let message_id = message_id.into();
            _params.extend([
                id::set(id),
                filename::set(filename),
                url::set(url),
                size_bytes::set(size_bytes),
                message_id::set(message_id),
            ]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod _count {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "_count";
        pub struct Order(super::SortOrder);
        pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByRelationAggregateParam {
            fn from(Order(v): Order) -> Self {
                Self::_Count(v)
            }
        }
    }
    pub mod deleted {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "deleted";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Deleted(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            Deleted,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Deleted(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Deleted(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Deleted(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Deleted(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Deleted(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Deleted(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Deleted(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod filename {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "filename";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: impl Into<String>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Filename(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Filename,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Filename(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Filename(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<String>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Filename(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Filename(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Filename(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Filename(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Filename(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::IdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Id(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Id, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Id(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod message {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "message";
        pub type Type = message::Data;
        pub type RecursiveSafeType = Box<message::Data>;
        pub fn is(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessageIs(value)
        }
        pub fn is_not(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessageIsNot(value)
        }
        pub struct Order(Vec<message::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<message::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Message(v)
            }
        }
        pub struct Fetch(pub message::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<message::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Message(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(message::UniqueArgs::new())
        }
        pub struct Connect(message::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectMessage(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: message::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub enum Select {
            Select(Vec<message::SelectParam>),
            Include(Vec<message::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Message(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<message::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<message::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("message", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<message::SelectParam>),
            Include(Vec<message::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Message(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<message::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<message::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("message", None, [], selections)
            }
        }
    }
    pub mod message_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "message_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            MessageId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::MessageId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::MessageId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::MessageId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::MessageId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::MessageId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MessageId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MessageId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod size_bytes {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "size_bytes";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::SizeBytes(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            SizeBytes,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::SizeBytes(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SizeBytes(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SizeBytes(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SizeBytes(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SizeBytes(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SizeBytes(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SizeBytes(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod url {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "url";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: impl Into<String>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Url(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Url, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Url(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Url(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<String>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Url(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Url(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Url(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Url(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Url(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
pub mod message {
    use super::_prisma::*;
    pub const NAME: &str = "Message";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(super::_prisma::read_filters::BigIntFilter),
        Content(super::_prisma::read_filters::StringFilter),
        AuthorIs(Vec<super::user::WhereParam>),
        AuthorIsNot(Vec<super::user::WhereParam>),
        AuthorId(super::_prisma::read_filters::BigIntFilter),
        ChannelIs(Vec<super::channel::WhereParam>),
        ChannelIsNot(Vec<super::channel::WhereParam>),
        ChannelId(super::_prisma::read_filters::BigIntFilter),
        AttachmentsSome(Vec<super::attachment::WhereParam>),
        AttachmentsEvery(Vec<super::attachment::WhereParam>),
        AttachmentsNone(Vec<super::attachment::WhereParam>),
        Created(super::_prisma::read_filters::DateTimeFilter),
        UpdatedAt(super::_prisma::read_filters::DateTimeFilter),
        Deleted(super::_prisma::read_filters::BooleanFilter),
        Edited(super::_prisma::read_filters::BooleanFilter),
        PinIsNull,
        PinIs(Vec<super::message_pin::WhereParam>),
        PinIsNot(Vec<super::message_pin::WhereParam>),
        ImpersonatedMessageIsNull,
        ImpersonatedMessageIs(Vec<super::impersonated_message_data::WhereParam>),
        ImpersonatedMessageIsNot(Vec<super::impersonated_message_data::WhereParam>),
        NewsInChatSome(Vec<super::news_in_chat::WhereParam>),
        NewsInChatEvery(Vec<super::news_in_chat::WhereParam>),
        NewsInChatNone(Vec<super::news_in_chat::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Content(value) => (content::NAME, value.into()),
                Self::AuthorIs(where_params) => (
                    author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthorIsNot(where_params) => (
                    author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthorId(value) => (author_id::NAME, value.into()),
                Self::ChannelIs(where_params) => (
                    channel::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChannelIsNot(where_params) => (
                    channel::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChannelId(value) => (channel_id::NAME, value.into()),
                Self::AttachmentsSome(where_params) => (
                    attachments::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AttachmentsEvery(where_params) => (
                    attachments::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AttachmentsNone(where_params) => (
                    attachments::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Created(value) => (created::NAME, value.into()),
                Self::UpdatedAt(value) => (updated_at::NAME, value.into()),
                Self::Deleted(value) => (deleted::NAME, value.into()),
                Self::Edited(value) => (edited::NAME, value.into()),
                Self::PinIsNull => (
                    pin::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::PinIs(where_params) => (
                    pin::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::PinIsNot(where_params) => (
                    pin::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ImpersonatedMessageIsNull => (
                    impersonated_message::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::ImpersonatedMessageIs(where_params) => (
                    impersonated_message::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ImpersonatedMessageIsNot(where_params) => (
                    impersonated_message::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NewsInChatSome(where_params) => (
                    news_in_chat::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NewsInChatEvery(where_params) => (
                    news_in_chat::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NewsInChatNone(where_params) => (
                    news_in_chat::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i64),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        Id(super::SortOrder),
        Content(super::SortOrder),
        AuthorId(super::SortOrder),
        ChannelId(super::SortOrder),
        Created(super::SortOrder),
        UpdatedAt(super::SortOrder),
        Deleted(super::SortOrder),
        Edited(super::SortOrder),
        Author(Vec<super::user::OrderByWithRelationParam>),
        Channel(Vec<super::channel::OrderByWithRelationParam>),
        Attachments(Vec<super::attachment::OrderByRelationAggregateParam>),
        Pin(Vec<super::message_pin::OrderByWithRelationParam>),
        ImpersonatedMessage(Vec<super::impersonated_message_data::OrderByWithRelationParam>),
        NewsInChat(Vec<super::news_in_chat::OrderByRelationAggregateParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(param) => ("id", param.into()),
                Self::Content(param) => ("content", param.into()),
                Self::AuthorId(param) => ("author_id", param.into()),
                Self::ChannelId(param) => ("channel_id", param.into()),
                Self::Created(param) => ("created", param.into()),
                Self::UpdatedAt(param) => ("updated_at", param.into()),
                Self::Deleted(param) => ("deleted", param.into()),
                Self::Edited(param) => ("edited", param.into()),
                Self::Author(param) => (
                    "author",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::Channel(param) => (
                    "channel",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::Attachments(param) => (
                    "attachments",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::Pin(param) => (
                    "pin",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::ImpersonatedMessage(param) => (
                    "impersonated_message",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::NewsInChat(param) => (
                    "NewsInChat",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByRelationAggregateParam {
        _Count(super::SortOrder),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::_Count(param) => ("_count", param.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {
        Author(super::user::UniqueArgs),
        Channel(super::channel::UniqueArgs),
        Attachments(super::attachment::ManyArgs),
        Pin(super::message_pin::UniqueArgs),
        ImpersonatedMessage(super::impersonated_message_data::UniqueArgs),
        NewsInChat(super::news_in_chat::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Author(args) => {
                    let mut selections =
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(author::NAME, None, [], selections)
                }
                Self::Channel(args) => {
                    let mut selections = < super :: channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(channel::NAME, None, [], selections)
                }
                Self::Attachments(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: attachment :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        attachments::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Pin(args) => {
                    let mut selections = < super :: message_pin :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(pin::NAME, None, [], selections)
                }
                Self::ImpersonatedMessage(args) => {
                    let mut selections = < super :: impersonated_message_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        impersonated_message::NAME,
                        None,
                        [],
                        selections,
                    )
                }
                Self::NewsInChat(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: news_in_chat :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        news_in_chat::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Content(super::_prisma::write_params::StringParam),
        ConnectAuthor(super::user::UniqueWhereParam),
        AuthorId(super::_prisma::write_params::BigIntParam),
        ConnectChannel(super::channel::UniqueWhereParam),
        ChannelId(super::_prisma::write_params::BigIntParam),
        ConnectAttachments(Vec<super::attachment::UniqueWhereParam>),
        DisconnectAttachments(Vec<super::attachment::UniqueWhereParam>),
        SetAttachments(Vec<super::attachment::UniqueWhereParam>),
        Created(super::_prisma::write_params::DateTimeParam),
        UpdatedAt(super::_prisma::write_params::DateTimeParam),
        Deleted(super::_prisma::write_params::BooleanParam),
        Edited(super::_prisma::write_params::BooleanParam),
        ConnectPin(super::message_pin::UniqueWhereParam),
        DisconnectPin,
        ConnectImpersonatedMessage(super::impersonated_message_data::UniqueWhereParam),
        DisconnectImpersonatedMessage,
        ConnectNewsInChat(Vec<super::news_in_chat::UniqueWhereParam>),
        DisconnectNewsInChat(Vec<super::news_in_chat::UniqueWhereParam>),
        SetNewsInChat(Vec<super::news_in_chat::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => (id::NAME, value.into()),
                Self::Content(value) => (content::NAME, value.into()),
                Self::ConnectAuthor(where_param) => (
                    author::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthorId(value) => (author_id::NAME, value.into()),
                Self::ConnectChannel(where_param) => (
                    channel::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChannelId(value) => (channel_id::NAME, value.into()),
                Self::ConnectAttachments(where_params) => (
                    attachments::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectAttachments(where_params) => (
                    attachments::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SetAttachments(where_params) => (
                    attachments::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::Created(value) => (created::NAME, value.into()),
                Self::UpdatedAt(value) => (updated_at::NAME, value.into()),
                Self::Deleted(value) => (deleted::NAME, value.into()),
                Self::Edited(value) => (edited::NAME, value.into()),
                Self::ConnectPin(where_param) => (
                    pin::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectPin => (
                    pin::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                Self::ConnectImpersonatedMessage(where_param) => (
                    impersonated_message::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectImpersonatedMessage => (
                    impersonated_message::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                Self::ConnectNewsInChat(where_params) => (
                    news_in_chat::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectNewsInChat(where_params) => (
                    news_in_chat::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SetNewsInChat(where_params) => (
                    news_in_chat::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Content(super::_prisma::write_params::StringParam),
        AuthorId(super::_prisma::write_params::BigIntParam),
        ChannelId(super::_prisma::write_params::BigIntParam),
        Created(super::_prisma::write_params::DateTimeParam),
        UpdatedAt(super::_prisma::write_params::DateTimeParam),
        Deleted(super::_prisma::write_params::BooleanParam),
        Edited(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => ("id", value.into()),
                Self::Content(value) => ("content", value.into()),
                Self::AuthorId(value) => ("author_id", value.into()),
                Self::ChannelId(value) => ("channel_id", value.into()),
                Self::Created(value) => ("created", value.into()),
                Self::UpdatedAt(value) => ("updated_at", value.into()),
                Self::Deleted(value) => ("deleted", value.into()),
                Self::Edited(value) => ("edited", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_message,
        select,
        generated::message,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "content")]
            content: content::Type,
            #[serde(rename = "author")]
            author: author::Type,
            #[serde(rename = "author_id")]
            author_id: author_id::Type,
            #[serde(rename = "channel")]
            channel: channel::Type,
            #[serde(rename = "channel_id")]
            channel_id: channel_id::Type,
            #[serde(rename = "attachments")]
            attachments: attachments::Type,
            #[serde(rename = "created")]
            created: created::Type,
            #[serde(rename = "updated_at")]
            updated_at: updated_at::Type,
            #[serde(rename = "deleted")]
            deleted: deleted::Type,
            #[serde(rename = "edited")]
            edited: edited::Type,
            #[serde(rename = "pin")]
            pin: pin::Type,
            #[serde(rename = "impersonated_message")]
            impersonated_message: impersonated_message::Type,
            #[serde(rename = "NewsInChat")]
            news_in_chat: news_in_chat::Type,
        },
        [
            (id, Scalar),
            (content, Scalar),
            (author, Relation(generated::user, One)),
            (author_id, Scalar),
            (channel, Relation(generated::channel, One)),
            (channel_id, Scalar),
            (attachments, Relation(generated::attachment, Many)),
            (created, Scalar),
            (updated_at, Scalar),
            (deleted, Scalar),
            (edited, Scalar),
            (pin, Relation(generated::message_pin, One)),
            (
                impersonated_message,
                Relation(generated::impersonated_message_data, One)
            ),
            (news_in_chat, Relation(generated::news_in_chat, Many))
        ]
    );
    pub enum SelectParam {
        Id(id::Select),
        Content(content::Select),
        Author(author::Select),
        AuthorId(author_id::Select),
        Channel(channel::Select),
        ChannelId(channel_id::Select),
        Attachments(attachments::Select),
        Created(created::Select),
        UpdatedAt(updated_at::Select),
        Deleted(deleted::Select),
        Edited(edited::Select),
        Pin(pin::Select),
        ImpersonatedMessage(impersonated_message::Select),
        NewsInChat(news_in_chat::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Content(data) => data.into(),
                Self::Author(data) => data.into(),
                Self::AuthorId(data) => data.into(),
                Self::Channel(data) => data.into(),
                Self::ChannelId(data) => data.into(),
                Self::Attachments(data) => data.into(),
                Self::Created(data) => data.into(),
                Self::UpdatedAt(data) => data.into(),
                Self::Deleted(data) => data.into(),
                Self::Edited(data) => data.into(),
                Self::Pin(data) => data.into(),
                Self::ImpersonatedMessage(data) => data.into(),
                Self::NewsInChat(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_message,
        include,
        generated::message,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "content")]
            content: content::Type,
            #[serde(rename = "author")]
            author: author::Type,
            #[serde(rename = "author_id")]
            author_id: author_id::Type,
            #[serde(rename = "channel")]
            channel: channel::Type,
            #[serde(rename = "channel_id")]
            channel_id: channel_id::Type,
            #[serde(rename = "attachments")]
            attachments: attachments::Type,
            #[serde(rename = "created")]
            created: created::Type,
            #[serde(rename = "updated_at")]
            updated_at: updated_at::Type,
            #[serde(rename = "deleted")]
            deleted: deleted::Type,
            #[serde(rename = "edited")]
            edited: edited::Type,
            #[serde(rename = "pin")]
            pin: pin::Type,
            #[serde(rename = "impersonated_message")]
            impersonated_message: impersonated_message::Type,
            #[serde(rename = "NewsInChat")]
            news_in_chat: news_in_chat::Type,
        },
        [
            (author, Relation(generated::user, One)),
            (channel, Relation(generated::channel, One)),
            (attachments, Relation(generated::attachment, Many)),
            (pin, Relation(generated::message_pin, One)),
            (
                impersonated_message,
                Relation(generated::impersonated_message_data, One)
            ),
            (news_in_chat, Relation(generated::news_in_chat, Many))
        ]
    );
    pub enum IncludeParam {
        Id(id::Include),
        Content(content::Include),
        Author(author::Include),
        AuthorId(author_id::Include),
        Channel(channel::Include),
        ChannelId(channel_id::Include),
        Attachments(attachments::Include),
        Created(created::Include),
        UpdatedAt(updated_at::Include),
        Deleted(deleted::Include),
        Edited(edited::Include),
        Pin(pin::Include),
        ImpersonatedMessage(impersonated_message::Include),
        NewsInChat(news_in_chat::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Content(data) => data.into(),
                Self::Author(data) => data.into(),
                Self::AuthorId(data) => data.into(),
                Self::Channel(data) => data.into(),
                Self::ChannelId(data) => data.into(),
                Self::Attachments(data) => data.into(),
                Self::Created(data) => data.into(),
                Self::UpdatedAt(data) => data.into(),
                Self::Deleted(data) => data.into(),
                Self::Edited(data) => data.into(),
                Self::Pin(data) => data.into(),
                Self::ImpersonatedMessage(data) => data.into(),
                Self::NewsInChat(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub id: i64,
        pub content: String,
        pub author: super::user::UniqueWhereParam,
        pub channel: super::channel::UniqueWhereParam,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client.message().create(
                self.id,
                self.content,
                self.author,
                self.channel,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([
                id::set(self.id),
                content::set(self.content),
                author::connect(self.author),
                channel::connect(self.channel),
            ]);
            self._params
        }
    }
    pub fn create(
        id: i64,
        content: String,
        author: super::user::UniqueWhereParam,
        channel: super::channel::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> Create {
        Create {
            id,
            content,
            author,
            channel,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub id: i64,
        pub content: String,
        pub author_id: i64,
        pub channel_id: i64,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client.message().create_unchecked(
                self.id,
                self.content,
                self.author_id,
                self.channel_id,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([
                id::set(self.id),
                content::set(self.content),
                author_id::set(self.author_id),
                channel_id::set(self.channel_id),
            ]);
            self._params
        }
    }
    pub fn create_unchecked(
        id: i64,
        content: String,
        author_id: i64,
        channel_id: i64,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            id,
            content,
            author_id,
            channel_id,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(content::NAME),
                ::prisma_client_rust::sel(author_id::NAME),
                ::prisma_client_rust::sel(channel_id::NAME),
                ::prisma_client_rust::sel(created::NAME),
                ::prisma_client_rust::sel(updated_at::NAME),
                ::prisma_client_rust::sel(deleted::NAME),
                ::prisma_client_rust::sel(edited::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: id::Type,
        #[serde(rename = "content")]
        pub content: content::Type,
        #[serde(rename = "author")]
        pub author: Option<author::RecursiveSafeType>,
        #[serde(rename = "author_id")]
        pub author_id: author_id::Type,
        #[serde(rename = "channel")]
        pub channel: Option<channel::RecursiveSafeType>,
        #[serde(rename = "channel_id")]
        pub channel_id: channel_id::Type,
        #[serde(rename = "attachments")]
        pub attachments: Option<attachments::RecursiveSafeType>,
        #[serde(rename = "created")]
        pub created: created::Type,
        #[serde(rename = "updated_at")]
        pub updated_at: updated_at::Type,
        #[serde(rename = "deleted")]
        pub deleted: deleted::Type,
        #[serde(rename = "edited")]
        pub edited: edited::Type,
        #[serde(
            rename = "pin",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub pin: Option<pin::RecursiveSafeType>,
        #[serde(
            rename = "impersonated_message",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub impersonated_message: Option<impersonated_message::RecursiveSafeType>,
        #[serde(rename = "NewsInChat")]
        pub news_in_chat: Option<news_in_chat::RecursiveSafeType>,
    }
    impl Data {
        pub fn author(
            &self,
        ) -> Result<&super::user::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.author
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(author),
                ))
                .map(|v| v.as_ref())
        }
        pub fn channel(
            &self,
        ) -> Result<&super::channel::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.channel
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(channel),
                ))
                .map(|v| v.as_ref())
        }
        pub fn attachments(
            &self,
        ) -> Result<&attachments::Type, ::prisma_client_rust::RelationNotFetchedError> {
            self.attachments
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(attachments),
                ))
        }
        pub fn pin(
            &self,
        ) -> Result<Option<&super::message_pin::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.pin
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(pin),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn impersonated_message(
            &self,
        ) -> Result<
            Option<&super::impersonated_message_data::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.impersonated_message
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(impersonated_message),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn news_in_chat(
            &self,
        ) -> Result<&news_in_chat::Type, ::prisma_client_rust::RelationNotFetchedError> {
            self.news_in_chat
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(news_in_chat),
                ))
        }
    }
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_message,
        generated::message,
        struct Data {
            #[serde(rename = "id")]
            pub id: generated::message::id::Type,
            #[serde(rename = "content")]
            pub content: generated::message::content::Type,
            #[serde(rename = "author_id")]
            pub author_id: generated::message::author_id::Type,
            #[serde(rename = "channel_id")]
            pub channel_id: generated::message::channel_id::Type,
            #[serde(rename = "created")]
            pub created: generated::message::created::Type,
            #[serde(rename = "updated_at")]
            pub updated_at: generated::message::updated_at::Type,
            #[serde(rename = "deleted")]
            pub deleted: generated::message::deleted::Type,
            #[serde(rename = "edited")]
            pub edited: generated::message::edited::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _message_filter,
        generated::message,
        [
            (id, Scalar),
            (content, Scalar),
            (author, Relation(generated::user, One)),
            (author_id, Scalar),
            (channel, Relation(generated::channel, One)),
            (channel_id, Scalar),
            (attachments, Relation(generated::attachment, Many)),
            (created, Scalar),
            (updated_at, Scalar),
            (deleted, Scalar),
            (edited, Scalar),
            (pin, Relation(generated::message_pin, One)),
            (
                impersonated_message,
                Relation(generated::impersonated_message_data, One)
            ),
            (news_in_chat, Relation(generated::news_in_chat, Many))
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            id: impl Into<i64>,
            content: impl Into<String>,
            author: super::user::UniqueWhereParam,
            channel: super::channel::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            let id = id.into();
            let content = content.into();
            let author = author.into();
            let channel = channel.into();
            _params.extend([
                id::set(id),
                content::set(content),
                author::connect(author),
                channel::connect(channel),
            ]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: impl Into<i64>,
            content: impl Into<String>,
            author_id: impl Into<i64>,
            channel_id: impl Into<i64>,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            let id = id.into();
            let content = content.into();
            let author_id = author_id.into();
            let channel_id = channel_id.into();
            _params.extend([
                id::set(id),
                content::set(content),
                author_id::set(author_id),
                channel_id::set(channel_id),
            ]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod news_in_chat {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "NewsInChat";
        pub type Type = Vec<news_in_chat::Data>;
        pub type RecursiveSafeType = Type;
        pub fn some(value: Vec<news_in_chat::WhereParam>) -> WhereParam {
            WhereParam::NewsInChatSome(value)
        }
        pub fn every(value: Vec<news_in_chat::WhereParam>) -> WhereParam {
            WhereParam::NewsInChatEvery(value)
        }
        pub fn none(value: Vec<news_in_chat::WhereParam>) -> WhereParam {
            WhereParam::NewsInChatNone(value)
        }
        pub struct Order(Vec<news_in_chat::OrderByRelationAggregateParam>);
        pub fn order<T: From<Order>>(v: Vec<news_in_chat::OrderByRelationAggregateParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::NewsInChat(v)
            }
        }
        pub struct Fetch(pub news_in_chat::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<news_in_chat::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: news_in_chat::OrderByWithRelationParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: news_in_chat::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::NewsInChat(v)
            }
        }
        pub fn fetch(params: Vec<news_in_chat::WhereParam>) -> Fetch {
            Fetch(news_in_chat::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<news_in_chat::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectNewsInChat(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<news_in_chat::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<news_in_chat::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectNewsInChat(params)
        }
        pub fn set(params: Vec<news_in_chat::UniqueWhereParam>) -> SetParam {
            SetParam::SetNewsInChat(params)
        }
        pub enum Select {
            Select(news_in_chat::ManyArgs, Vec<news_in_chat::SelectParam>),
            Include(news_in_chat::ManyArgs, Vec<news_in_chat::IncludeParam>),
            Fetch(news_in_chat::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::NewsInChat(self)
            }
        }
        impl Select {
            pub fn select(
                args: news_in_chat::ManyArgs,
                nested_selections: Vec<news_in_chat::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: news_in_chat::ManyArgs,
                nested_selections: Vec<news_in_chat::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < news_in_chat :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
        pub enum Include {
            Select(news_in_chat::ManyArgs, Vec<news_in_chat::SelectParam>),
            Include(news_in_chat::ManyArgs, Vec<news_in_chat::IncludeParam>),
            Fetch(news_in_chat::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::NewsInChat(self)
            }
        }
        impl Include {
            pub fn select(
                args: news_in_chat::ManyArgs,
                nested_selections: Vec<news_in_chat::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: news_in_chat::ManyArgs,
                nested_selections: Vec<news_in_chat::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < news_in_chat :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < news_in_chat :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
    }
    pub mod _count {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "_count";
        pub struct Order(super::SortOrder);
        pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByRelationAggregateParam {
            fn from(Order(v): Order) -> Self {
                Self::_Count(v)
            }
        }
    }
    pub mod attachments {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "attachments";
        pub type Type = Vec<attachment::Data>;
        pub type RecursiveSafeType = Type;
        pub fn some(value: Vec<attachment::WhereParam>) -> WhereParam {
            WhereParam::AttachmentsSome(value)
        }
        pub fn every(value: Vec<attachment::WhereParam>) -> WhereParam {
            WhereParam::AttachmentsEvery(value)
        }
        pub fn none(value: Vec<attachment::WhereParam>) -> WhereParam {
            WhereParam::AttachmentsNone(value)
        }
        pub struct Order(Vec<attachment::OrderByRelationAggregateParam>);
        pub fn order<T: From<Order>>(v: Vec<attachment::OrderByRelationAggregateParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Attachments(v)
            }
        }
        pub struct Fetch(pub attachment::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<attachment::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: attachment::OrderByWithRelationParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: attachment::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Attachments(v)
            }
        }
        pub fn fetch(params: Vec<attachment::WhereParam>) -> Fetch {
            Fetch(attachment::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<attachment::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAttachments(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<attachment::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<attachment::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAttachments(params)
        }
        pub fn set(params: Vec<attachment::UniqueWhereParam>) -> SetParam {
            SetParam::SetAttachments(params)
        }
        pub enum Select {
            Select(attachment::ManyArgs, Vec<attachment::SelectParam>),
            Include(attachment::ManyArgs, Vec<attachment::IncludeParam>),
            Fetch(attachment::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Attachments(self)
            }
        }
        impl Select {
            pub fn select(
                args: attachment::ManyArgs,
                nested_selections: Vec<attachment::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: attachment::ManyArgs,
                nested_selections: Vec<attachment::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <attachment::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
        pub enum Include {
            Select(attachment::ManyArgs, Vec<attachment::SelectParam>),
            Include(attachment::ManyArgs, Vec<attachment::IncludeParam>),
            Fetch(attachment::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Attachments(self)
            }
        }
        impl Include {
            pub fn select(
                args: attachment::ManyArgs,
                nested_selections: Vec<attachment::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: attachment::ManyArgs,
                nested_selections: Vec<attachment::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < attachment :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <attachment::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
    }
    pub mod author {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "author";
        pub type Type = user::Data;
        pub type RecursiveSafeType = Box<user::Data>;
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::AuthorIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::AuthorIsNot(value)
        }
        pub struct Order(Vec<user::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<user::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Author(v)
            }
        }
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Author(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAuthor(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Author(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("author", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Author(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("author", None, [], selections)
            }
        }
    }
    pub mod author_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "author_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            AuthorId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::AuthorId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::AuthorId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::AuthorId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::AuthorId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::AuthorId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AuthorId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AuthorId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod channel {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "channel";
        pub type Type = channel::Data;
        pub type RecursiveSafeType = Box<channel::Data>;
        pub fn is(value: Vec<channel::WhereParam>) -> WhereParam {
            WhereParam::ChannelIs(value)
        }
        pub fn is_not(value: Vec<channel::WhereParam>) -> WhereParam {
            WhereParam::ChannelIsNot(value)
        }
        pub struct Order(Vec<channel::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<channel::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Channel(v)
            }
        }
        pub struct Fetch(pub channel::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<channel::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Channel(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(channel::UniqueArgs::new())
        }
        pub struct Connect(channel::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectChannel(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: channel::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub enum Select {
            Select(Vec<channel::SelectParam>),
            Include(Vec<channel::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Channel(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<channel::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<channel::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <channel::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("channel", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<channel::SelectParam>),
            Include(Vec<channel::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Channel(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<channel::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<channel::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <channel::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <channel::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("channel", None, [], selections)
            }
        }
    }
    pub mod channel_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "channel_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            ChannelId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::ChannelId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::ChannelId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ChannelId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ChannelId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ChannelId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChannelId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChannelId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod content {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "content";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: impl Into<String>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Content(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Content,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Content(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Content(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<String>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Content(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Content(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Content(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Content(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Content(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "created";
        pub type Type =
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>;
        pub type RecursiveSafeType = Type;
        pub struct Equals(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        pub fn equals<T: From<Equals>>(
            value: impl Into<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Created(_prisma::read_filters::DateTimeFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            Created,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Created(v)
            }
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Created(_prisma::write_params::DateTimeParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(
            value: impl Into<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Created(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Created(_prisma::write_params::DateTimeParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Created(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Created(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Created(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod deleted {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "deleted";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Deleted(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            Deleted,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Deleted(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Deleted(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Deleted(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Deleted(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Deleted(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Deleted(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Deleted(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod edited {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "edited";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Edited(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            Edited,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Edited(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Edited(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Edited(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Edited(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Edited(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Edited(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Edited(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::IdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Id(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Id, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Id(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod impersonated_message {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "impersonated_message";
        pub type Type = Option<impersonated_message_data::Data>;
        pub type RecursiveSafeType = Option<Box<impersonated_message_data::Data>>;
        pub fn is(value: Vec<impersonated_message_data::WhereParam>) -> WhereParam {
            WhereParam::ImpersonatedMessageIs(value)
        }
        pub fn is_not(value: Vec<impersonated_message_data::WhereParam>) -> WhereParam {
            WhereParam::ImpersonatedMessageIsNot(value)
        }
        pub struct Order(Vec<impersonated_message_data::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(
            v: Vec<impersonated_message_data::OrderByWithRelationParam>,
        ) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::ImpersonatedMessage(v)
            }
        }
        pub struct Fetch(pub impersonated_message_data::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<impersonated_message_data::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ImpersonatedMessage(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(impersonated_message_data::UniqueArgs::new())
        }
        pub struct Connect(impersonated_message_data::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectImpersonatedMessage(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: impersonated_message_data::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectImpersonatedMessage
        }
        pub fn is_null() -> WhereParam {
            WhereParam::ImpersonatedMessageIsNull
        }
        pub enum Select {
            Select(Vec<impersonated_message_data::SelectParam>),
            Include(Vec<impersonated_message_data::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ImpersonatedMessage(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<impersonated_message_data::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(
                nested_selections: Vec<impersonated_message_data::IncludeParam>,
            ) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < impersonated_message_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("impersonated_message", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<impersonated_message_data::SelectParam>),
            Include(Vec<impersonated_message_data::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ImpersonatedMessage(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<impersonated_message_data::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(
                nested_selections: Vec<impersonated_message_data::IncludeParam>,
            ) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < impersonated_message_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < impersonated_message_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("impersonated_message", None, [], selections)
            }
        }
    }
    pub mod pin {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "pin";
        pub type Type = Option<message_pin::Data>;
        pub type RecursiveSafeType = Option<Box<message_pin::Data>>;
        pub fn is(value: Vec<message_pin::WhereParam>) -> WhereParam {
            WhereParam::PinIs(value)
        }
        pub fn is_not(value: Vec<message_pin::WhereParam>) -> WhereParam {
            WhereParam::PinIsNot(value)
        }
        pub struct Order(Vec<message_pin::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<message_pin::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Pin(v)
            }
        }
        pub struct Fetch(pub message_pin::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<message_pin::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Pin(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(message_pin::UniqueArgs::new())
        }
        pub struct Connect(message_pin::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectPin(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: message_pin::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectPin
        }
        pub fn is_null() -> WhereParam {
            WhereParam::PinIsNull
        }
        pub enum Select {
            Select(Vec<message_pin::SelectParam>),
            Include(Vec<message_pin::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Pin(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<message_pin::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<message_pin::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <message_pin::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        )
                    }
                };
                ::prisma_client_rust::Selection::new("pin", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<message_pin::SelectParam>),
            Include(Vec<message_pin::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Pin(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<message_pin::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<message_pin::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = < message_pin :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <message_pin::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        )
                    }
                };
                ::prisma_client_rust::Selection::new("pin", None, [], selections)
            }
        }
    }
    pub mod updated_at {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "updated_at";
        pub type Type =
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>;
        pub type RecursiveSafeType = Type;
        pub struct Equals(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        pub fn equals<T: From<Equals>>(
            value: impl Into<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            UpdatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::UpdatedAt(v)
            }
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::UpdatedAt(_prisma::write_params::DateTimeParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(
            value: impl Into<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::UpdatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UpdatedAt(_prisma::write_params::DateTimeParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::UpdatedAt(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UpdatedAt(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UpdatedAt(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
pub mod message_pin {
    use super::_prisma::*;
    pub const NAME: &str = "MessagePin";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        PinnedMessageId(super::_prisma::read_filters::BigIntFilter),
        OriginalIs(Vec<super::message::WhereParam>),
        OriginalIsNot(Vec<super::message::WhereParam>),
        OriginalId(super::_prisma::read_filters::BigIntFilter),
        Removed(super::_prisma::read_filters::BooleanFilter),
        RemovedReason(super::_prisma::read_filters::StringNullableFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::PinnedMessageId(value) => (pinned_message_id::NAME, value.into()),
                Self::OriginalIs(where_params) => (
                    original::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::OriginalIsNot(where_params) => (
                    original::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::OriginalId(value) => (original_id::NAME, value.into()),
                Self::Removed(value) => (removed::NAME, value.into()),
                Self::RemovedReason(value) => (removed_reason::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        OriginalIdEquals(i64),
        PinnedMessageIdEquals(i64),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::OriginalIdEquals(value) => (
                    "original_id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
                UniqueWhereParam::PinnedMessageIdEquals(value) => (
                    "pinned_message_id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        PinnedMessageId(super::SortOrder),
        OriginalId(super::SortOrder),
        Removed(super::SortOrder),
        RemovedReason(super::SortOrder),
        Original(Vec<super::message::OrderByWithRelationParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::PinnedMessageId(param) => ("pinned_message_id", param.into()),
                Self::OriginalId(param) => ("original_id", param.into()),
                Self::Removed(param) => ("removed", param.into()),
                Self::RemovedReason(param) => ("removed_reason", param.into()),
                Self::Original(param) => (
                    "original",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {
        Original(super::message::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Original(args) => {
                    let mut selections = < super :: message :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(original::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        PinnedMessageId(super::_prisma::write_params::BigIntParam),
        ConnectOriginal(super::message::UniqueWhereParam),
        OriginalId(super::_prisma::write_params::BigIntParam),
        Removed(super::_prisma::write_params::BooleanParam),
        RemovedReason(super::_prisma::write_params::StringNullableParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::PinnedMessageId(value) => (pinned_message_id::NAME, value.into()),
                Self::ConnectOriginal(where_param) => (
                    original::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::OriginalId(value) => (original_id::NAME, value.into()),
                Self::Removed(value) => (removed::NAME, value.into()),
                Self::RemovedReason(value) => (removed_reason::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        PinnedMessageId(super::_prisma::write_params::BigIntParam),
        OriginalId(super::_prisma::write_params::BigIntParam),
        Removed(super::_prisma::write_params::BooleanParam),
        RemovedReason(super::_prisma::write_params::StringNullableParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::PinnedMessageId(value) => ("pinned_message_id", value.into()),
                Self::OriginalId(value) => ("original_id", value.into()),
                Self::Removed(value) => ("removed", value.into()),
                Self::RemovedReason(value) => ("removed_reason", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_message_pin,
        select,
        generated::message_pin,
        struct Data {
            #[serde(rename = "pinned_message_id")]
            pinned_message_id: pinned_message_id::Type,
            #[serde(rename = "original")]
            original: original::Type,
            #[serde(rename = "original_id")]
            original_id: original_id::Type,
            #[serde(rename = "removed")]
            removed: removed::Type,
            #[serde(rename = "removed_reason")]
            removed_reason: removed_reason::Type,
        },
        [
            (pinned_message_id, Scalar),
            (original, Relation(generated::message, One)),
            (original_id, Scalar),
            (removed, Scalar),
            (removed_reason, Scalar)
        ]
    );
    pub enum SelectParam {
        PinnedMessageId(pinned_message_id::Select),
        Original(original::Select),
        OriginalId(original_id::Select),
        Removed(removed::Select),
        RemovedReason(removed_reason::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::PinnedMessageId(data) => data.into(),
                Self::Original(data) => data.into(),
                Self::OriginalId(data) => data.into(),
                Self::Removed(data) => data.into(),
                Self::RemovedReason(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_message_pin,
        include,
        generated::message_pin,
        struct Data {
            #[serde(rename = "pinned_message_id")]
            pinned_message_id: pinned_message_id::Type,
            #[serde(rename = "original")]
            original: original::Type,
            #[serde(rename = "original_id")]
            original_id: original_id::Type,
            #[serde(rename = "removed")]
            removed: removed::Type,
            #[serde(rename = "removed_reason")]
            removed_reason: removed_reason::Type,
        },
        [(original, Relation(generated::message, One))]
    );
    pub enum IncludeParam {
        PinnedMessageId(pinned_message_id::Include),
        Original(original::Include),
        OriginalId(original_id::Include),
        Removed(removed::Include),
        RemovedReason(removed_reason::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::PinnedMessageId(data) => data.into(),
                Self::Original(data) => data.into(),
                Self::OriginalId(data) => data.into(),
                Self::Removed(data) => data.into(),
                Self::RemovedReason(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub pinned_message_id: i64,
        pub original: super::message::UniqueWhereParam,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client
                .message_pin()
                .create(self.pinned_message_id, self.original, self._params)
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([
                pinned_message_id::set(self.pinned_message_id),
                original::connect(self.original),
            ]);
            self._params
        }
    }
    pub fn create(
        pinned_message_id: i64,
        original: super::message::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> Create {
        Create {
            pinned_message_id,
            original,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub pinned_message_id: i64,
        pub original_id: i64,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client.message_pin().create_unchecked(
                self.pinned_message_id,
                self.original_id,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([
                pinned_message_id::set(self.pinned_message_id),
                original_id::set(self.original_id),
            ]);
            self._params
        }
    }
    pub fn create_unchecked(
        pinned_message_id: i64,
        original_id: i64,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            pinned_message_id,
            original_id,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(pinned_message_id::NAME),
                ::prisma_client_rust::sel(original_id::NAME),
                ::prisma_client_rust::sel(removed::NAME),
                ::prisma_client_rust::sel(removed_reason::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "pinned_message_id")]
        pub pinned_message_id: pinned_message_id::Type,
        #[serde(rename = "original")]
        pub original: Option<original::RecursiveSafeType>,
        #[serde(rename = "original_id")]
        pub original_id: original_id::Type,
        #[serde(rename = "removed")]
        pub removed: removed::Type,
        #[serde(rename = "removed_reason")]
        pub removed_reason: removed_reason::Type,
    }
    impl Data {
        pub fn original(
            &self,
        ) -> Result<&super::message::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.original
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(original),
                ))
                .map(|v| v.as_ref())
        }
    }
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_message_pin,
        generated::message_pin,
        struct Data {
            #[serde(rename = "pinned_message_id")]
            pub pinned_message_id: generated::message_pin::pinned_message_id::Type,
            #[serde(rename = "original_id")]
            pub original_id: generated::message_pin::original_id::Type,
            #[serde(rename = "removed")]
            pub removed: generated::message_pin::removed::Type,
            #[serde(rename = "removed_reason")]
            #[serde(default, with = "::prisma_client_rust::serde::double_option")]
            pub removed_reason: generated::message_pin::removed_reason::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _message_pin_filter,
        generated::message_pin,
        [
            (pinned_message_id, Scalar),
            (original, Relation(generated::message, One)),
            (original_id, Scalar),
            (removed, Scalar),
            (removed_reason, Scalar)
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            pinned_message_id: impl Into<i64>,
            original: super::message::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            let pinned_message_id = pinned_message_id.into();
            let original = original.into();
            _params.extend([
                pinned_message_id::set(pinned_message_id),
                original::connect(original),
            ]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            pinned_message_id: impl Into<i64>,
            original_id: impl Into<i64>,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            let pinned_message_id = pinned_message_id.into();
            let original_id = original_id.into();
            _params.extend([
                pinned_message_id::set(pinned_message_id),
                original_id::set(original_id),
            ]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod original {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "original";
        pub type Type = message::Data;
        pub type RecursiveSafeType = Box<message::Data>;
        pub fn is(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::OriginalIs(value)
        }
        pub fn is_not(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::OriginalIsNot(value)
        }
        pub struct Order(Vec<message::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<message::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Original(v)
            }
        }
        pub struct Fetch(pub message::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<message::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Original(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(message::UniqueArgs::new())
        }
        pub struct Connect(message::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectOriginal(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: message::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub enum Select {
            Select(Vec<message::SelectParam>),
            Include(Vec<message::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Original(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<message::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<message::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("original", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<message::SelectParam>),
            Include(Vec<message::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Original(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<message::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<message::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("original", None, [], selections)
            }
        }
    }
    pub mod original_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "original_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::OriginalIdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::OriginalId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            OriginalId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::OriginalId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::OriginalId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::OriginalId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::OriginalId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::OriginalId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::OriginalId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::OriginalId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod pinned_message_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "pinned_message_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::PinnedMessageIdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::PinnedMessageId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            PinnedMessageId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::PinnedMessageId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::PinnedMessageId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::PinnedMessageId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PinnedMessageId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::PinnedMessageId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PinnedMessageId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PinnedMessageId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod removed {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "removed";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Removed(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            Removed,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Removed(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Removed(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Removed(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Removed(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Removed(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Removed(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Removed(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod removed_reason {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "removed_reason";
        pub type Type = Option<String>;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Option<String>);
        pub fn equals<T: From<Equals>>(value: impl Into<Option<String>>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::RemovedReason(_prisma::read_filters::StringNullableFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            RemovedReason,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::RemovedReason(v)
            }
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::RemovedReason(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<Option<String>>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::RemovedReason(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::RemovedReason(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::RemovedReason(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RemovedReason(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RemovedReason(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
pub mod channel {
    use super::_prisma::*;
    pub const NAME: &str = "Channel";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(super::_prisma::read_filters::BigIntFilter),
        Name(super::_prisma::read_filters::StringFilter),
        Topic(super::_prisma::read_filters::StringNullableFilter),
        Nsfw(super::_prisma::read_filters::BooleanFilter),
        Kind(super::_prisma::read_filters::ChannelTypeFilter),
        MessagesSome(Vec<super::message::WhereParam>),
        MessagesEvery(Vec<super::message::WhereParam>),
        MessagesNone(Vec<super::message::WhereParam>),
        InteractionsSome(Vec<super::interaction::WhereParam>),
        InteractionsEvery(Vec<super::interaction::WhereParam>),
        InteractionsNone(Vec<super::interaction::WhereParam>),
        CategoryIsNull,
        CategoryIs(Vec<super::channel_category::WhereParam>),
        CategoryIsNot(Vec<super::channel_category::WhereParam>),
        CategoryId(super::_prisma::read_filters::BigIntNullableFilter),
        Deleted(super::_prisma::read_filters::BooleanFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Topic(value) => (topic::NAME, value.into()),
                Self::Nsfw(value) => (nsfw::NAME, value.into()),
                Self::Kind(value) => (kind::NAME, value.into()),
                Self::MessagesSome(where_params) => (
                    messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessagesEvery(where_params) => (
                    messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessagesNone(where_params) => (
                    messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InteractionsSome(where_params) => (
                    interactions::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InteractionsEvery(where_params) => (
                    interactions::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InteractionsNone(where_params) => (
                    interactions::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CategoryIsNull => (
                    category::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::CategoryIs(where_params) => (
                    category::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CategoryIsNot(where_params) => (
                    category::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CategoryId(value) => (category_id::NAME, value.into()),
                Self::Deleted(value) => (deleted::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i64),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        Id(super::SortOrder),
        Name(super::SortOrder),
        Topic(super::SortOrder),
        Nsfw(super::SortOrder),
        Kind(super::SortOrder),
        CategoryId(super::SortOrder),
        Deleted(super::SortOrder),
        Messages(Vec<super::message::OrderByRelationAggregateParam>),
        Interactions(Vec<super::interaction::OrderByRelationAggregateParam>),
        Category(Vec<super::channel_category::OrderByWithRelationParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(param) => ("id", param.into()),
                Self::Name(param) => ("name", param.into()),
                Self::Topic(param) => ("topic", param.into()),
                Self::Nsfw(param) => ("nsfw", param.into()),
                Self::Kind(param) => ("kind", param.into()),
                Self::CategoryId(param) => ("category_id", param.into()),
                Self::Deleted(param) => ("deleted", param.into()),
                Self::Messages(param) => (
                    "messages",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::Interactions(param) => (
                    "interactions",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::Category(param) => (
                    "category",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByRelationAggregateParam {
        _Count(super::SortOrder),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::_Count(param) => ("_count", param.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {
        Messages(super::message::ManyArgs),
        Interactions(super::interaction::ManyArgs),
        Category(super::channel_category::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Messages(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: message :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        messages::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Interactions(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: interaction :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        interactions::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Category(args) => {
                    let mut selections = < super :: channel_category :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(category::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Name(super::_prisma::write_params::StringParam),
        Topic(super::_prisma::write_params::StringNullableParam),
        Nsfw(super::_prisma::write_params::BooleanParam),
        Kind(super::_prisma::write_params::ChannelTypeParam),
        ConnectMessages(Vec<super::message::UniqueWhereParam>),
        DisconnectMessages(Vec<super::message::UniqueWhereParam>),
        SetMessages(Vec<super::message::UniqueWhereParam>),
        ConnectInteractions(Vec<super::interaction::UniqueWhereParam>),
        DisconnectInteractions(Vec<super::interaction::UniqueWhereParam>),
        SetInteractions(Vec<super::interaction::UniqueWhereParam>),
        ConnectCategory(super::channel_category::UniqueWhereParam),
        DisconnectCategory,
        CategoryId(super::_prisma::write_params::BigIntNullableParam),
        Deleted(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Topic(value) => (topic::NAME, value.into()),
                Self::Nsfw(value) => (nsfw::NAME, value.into()),
                Self::Kind(value) => (kind::NAME, value.into()),
                Self::ConnectMessages(where_params) => (
                    messages::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectMessages(where_params) => (
                    messages::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SetMessages(where_params) => (
                    messages::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ConnectInteractions(where_params) => (
                    interactions::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectInteractions(where_params) => (
                    interactions::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SetInteractions(where_params) => (
                    interactions::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ConnectCategory(where_param) => (
                    category::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectCategory => (
                    category::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                Self::CategoryId(value) => (category_id::NAME, value.into()),
                Self::Deleted(value) => (deleted::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Name(super::_prisma::write_params::StringParam),
        Topic(super::_prisma::write_params::StringNullableParam),
        Nsfw(super::_prisma::write_params::BooleanParam),
        Kind(super::_prisma::write_params::ChannelTypeParam),
        CategoryId(super::_prisma::write_params::BigIntNullableParam),
        Deleted(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => ("id", value.into()),
                Self::Name(value) => ("name", value.into()),
                Self::Topic(value) => ("topic", value.into()),
                Self::Nsfw(value) => ("nsfw", value.into()),
                Self::Kind(value) => ("kind", value.into()),
                Self::CategoryId(value) => ("category_id", value.into()),
                Self::Deleted(value) => ("deleted", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_channel,
        select,
        generated::channel,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "name")]
            name: name::Type,
            #[serde(rename = "topic")]
            topic: topic::Type,
            #[serde(rename = "nsfw")]
            nsfw: nsfw::Type,
            #[serde(rename = "kind")]
            kind: kind::Type,
            #[serde(rename = "messages")]
            messages: messages::Type,
            #[serde(rename = "interactions")]
            interactions: interactions::Type,
            #[serde(rename = "category")]
            category: category::Type,
            #[serde(rename = "category_id")]
            category_id: category_id::Type,
            #[serde(rename = "deleted")]
            deleted: deleted::Type,
        },
        [
            (id, Scalar),
            (name, Scalar),
            (topic, Scalar),
            (nsfw, Scalar),
            (kind, Scalar),
            (messages, Relation(generated::message, Many)),
            (interactions, Relation(generated::interaction, Many)),
            (category, Relation(generated::channel_category, One)),
            (category_id, Scalar),
            (deleted, Scalar)
        ]
    );
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Topic(topic::Select),
        Nsfw(nsfw::Select),
        Kind(kind::Select),
        Messages(messages::Select),
        Interactions(interactions::Select),
        Category(category::Select),
        CategoryId(category_id::Select),
        Deleted(deleted::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Name(data) => data.into(),
                Self::Topic(data) => data.into(),
                Self::Nsfw(data) => data.into(),
                Self::Kind(data) => data.into(),
                Self::Messages(data) => data.into(),
                Self::Interactions(data) => data.into(),
                Self::Category(data) => data.into(),
                Self::CategoryId(data) => data.into(),
                Self::Deleted(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_channel,
        include,
        generated::channel,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "name")]
            name: name::Type,
            #[serde(rename = "topic")]
            topic: topic::Type,
            #[serde(rename = "nsfw")]
            nsfw: nsfw::Type,
            #[serde(rename = "kind")]
            kind: kind::Type,
            #[serde(rename = "messages")]
            messages: messages::Type,
            #[serde(rename = "interactions")]
            interactions: interactions::Type,
            #[serde(rename = "category")]
            category: category::Type,
            #[serde(rename = "category_id")]
            category_id: category_id::Type,
            #[serde(rename = "deleted")]
            deleted: deleted::Type,
        },
        [
            (messages, Relation(generated::message, Many)),
            (interactions, Relation(generated::interaction, Many)),
            (category, Relation(generated::channel_category, One))
        ]
    );
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Topic(topic::Include),
        Nsfw(nsfw::Include),
        Kind(kind::Include),
        Messages(messages::Include),
        Interactions(interactions::Include),
        Category(category::Include),
        CategoryId(category_id::Include),
        Deleted(deleted::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Name(data) => data.into(),
                Self::Topic(data) => data.into(),
                Self::Nsfw(data) => data.into(),
                Self::Kind(data) => data.into(),
                Self::Messages(data) => data.into(),
                Self::Interactions(data) => data.into(),
                Self::Category(data) => data.into(),
                Self::CategoryId(data) => data.into(),
                Self::Deleted(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub id: i64,
        pub name: String,
        pub nsfw: bool,
        pub kind: super::ChannelType,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client
                .channel()
                .create(self.id, self.name, self.nsfw, self.kind, self._params)
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([
                id::set(self.id),
                name::set(self.name),
                nsfw::set(self.nsfw),
                kind::set(self.kind),
            ]);
            self._params
        }
    }
    pub fn create(
        id: i64,
        name: String,
        nsfw: bool,
        kind: super::ChannelType,
        _params: Vec<SetParam>,
    ) -> Create {
        Create {
            id,
            name,
            nsfw,
            kind,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub id: i64,
        pub name: String,
        pub nsfw: bool,
        pub kind: super::ChannelType,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client.channel().create_unchecked(
                self.id,
                self.name,
                self.nsfw,
                self.kind,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([
                id::set(self.id),
                name::set(self.name),
                nsfw::set(self.nsfw),
                kind::set(self.kind),
            ]);
            self._params
        }
    }
    pub fn create_unchecked(
        id: i64,
        name: String,
        nsfw: bool,
        kind: super::ChannelType,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            id,
            name,
            nsfw,
            kind,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(topic::NAME),
                ::prisma_client_rust::sel(nsfw::NAME),
                ::prisma_client_rust::sel(kind::NAME),
                ::prisma_client_rust::sel(category_id::NAME),
                ::prisma_client_rust::sel(deleted::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: id::Type,
        #[serde(rename = "name")]
        pub name: name::Type,
        #[serde(rename = "topic")]
        pub topic: topic::Type,
        #[serde(rename = "nsfw")]
        pub nsfw: nsfw::Type,
        #[serde(rename = "kind")]
        pub kind: kind::Type,
        #[serde(rename = "messages")]
        pub messages: Option<messages::RecursiveSafeType>,
        #[serde(rename = "interactions")]
        pub interactions: Option<interactions::RecursiveSafeType>,
        #[serde(
            rename = "category",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub category: Option<category::RecursiveSafeType>,
        #[serde(rename = "category_id")]
        pub category_id: category_id::Type,
        #[serde(rename = "deleted")]
        pub deleted: deleted::Type,
    }
    impl Data {
        pub fn messages(
            &self,
        ) -> Result<&messages::Type, ::prisma_client_rust::RelationNotFetchedError> {
            self.messages
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(messages),
                ))
        }
        pub fn interactions(
            &self,
        ) -> Result<&interactions::Type, ::prisma_client_rust::RelationNotFetchedError> {
            self.interactions
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(interactions),
                ))
        }
        pub fn category(
            &self,
        ) -> Result<
            Option<&super::channel_category::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.category
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(category),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_channel,
        generated::channel,
        struct Data {
            #[serde(rename = "id")]
            pub id: generated::channel::id::Type,
            #[serde(rename = "name")]
            pub name: generated::channel::name::Type,
            #[serde(rename = "topic")]
            #[serde(default, with = "::prisma_client_rust::serde::double_option")]
            pub topic: generated::channel::topic::Type,
            #[serde(rename = "nsfw")]
            pub nsfw: generated::channel::nsfw::Type,
            #[serde(rename = "kind")]
            pub kind: generated::channel::kind::Type,
            #[serde(rename = "category_id")]
            #[serde(default, with = "::prisma_client_rust::serde::double_option")]
            pub category_id: generated::channel::category_id::Type,
            #[serde(rename = "deleted")]
            pub deleted: generated::channel::deleted::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _channel_filter,
        generated::channel,
        [
            (id, Scalar),
            (name, Scalar),
            (topic, Scalar),
            (nsfw, Scalar),
            (kind, Scalar),
            (messages, Relation(generated::message, Many)),
            (interactions, Relation(generated::interaction, Many)),
            (category, Relation(generated::channel_category, One)),
            (category_id, Scalar),
            (deleted, Scalar)
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            id: impl Into<i64>,
            name: impl Into<String>,
            nsfw: impl Into<bool>,
            kind: impl Into<super::ChannelType>,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            let id = id.into();
            let name = name.into();
            let nsfw = nsfw.into();
            let kind = kind.into();
            _params.extend([
                id::set(id),
                name::set(name),
                nsfw::set(nsfw),
                kind::set(kind),
            ]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: impl Into<i64>,
            name: impl Into<String>,
            nsfw: impl Into<bool>,
            kind: impl Into<super::ChannelType>,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            let id = id.into();
            let name = name.into();
            let nsfw = nsfw.into();
            let kind = kind.into();
            _params.extend([
                id::set(id),
                name::set(name),
                nsfw::set(nsfw),
                kind::set(kind),
            ]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod _count {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "_count";
        pub struct Order(super::SortOrder);
        pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByRelationAggregateParam {
            fn from(Order(v): Order) -> Self {
                Self::_Count(v)
            }
        }
    }
    pub mod category {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "category";
        pub type Type = Option<channel_category::Data>;
        pub type RecursiveSafeType = Option<Box<channel_category::Data>>;
        pub fn is(value: Vec<channel_category::WhereParam>) -> WhereParam {
            WhereParam::CategoryIs(value)
        }
        pub fn is_not(value: Vec<channel_category::WhereParam>) -> WhereParam {
            WhereParam::CategoryIsNot(value)
        }
        pub struct Order(Vec<channel_category::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<channel_category::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Category(v)
            }
        }
        pub struct Fetch(pub channel_category::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<channel_category::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Category(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(channel_category::UniqueArgs::new())
        }
        pub struct Connect(channel_category::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectCategory(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: channel_category::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectCategory
        }
        pub fn is_null() -> WhereParam {
            WhereParam::CategoryIsNull
        }
        pub enum Select {
            Select(Vec<channel_category::SelectParam>),
            Include(Vec<channel_category::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Category(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<channel_category::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<channel_category::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < channel_category :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("category", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<channel_category::SelectParam>),
            Include(Vec<channel_category::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Category(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<channel_category::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<channel_category::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < channel_category :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < channel_category :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("category", None, [], selections)
            }
        }
    }
    pub mod category_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "category_id";
        pub type Type = Option<i64>;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Option<i64>);
        pub fn equals<T: From<Equals>>(value: impl Into<Option<i64>>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::CategoryId(_prisma::read_filters::BigIntNullableFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntNullableFilter,
            CategoryId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: Option<i64>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::CategoryId(v)
            }
        }
        pub struct Set(pub Option<i64>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::CategoryId(_prisma::write_params::BigIntNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<Option<i64>>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntNullableParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::CategoryId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntNullableParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntNullableParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntNullableParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntNullableParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CategoryId(_prisma::write_params::BigIntNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::CategoryId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CategoryId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CategoryId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod deleted {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "deleted";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Deleted(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            Deleted,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Deleted(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Deleted(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Deleted(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Deleted(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Deleted(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Deleted(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Deleted(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::IdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Id(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Id, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Id(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod interactions {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "interactions";
        pub type Type = Vec<interaction::Data>;
        pub type RecursiveSafeType = Type;
        pub fn some(value: Vec<interaction::WhereParam>) -> WhereParam {
            WhereParam::InteractionsSome(value)
        }
        pub fn every(value: Vec<interaction::WhereParam>) -> WhereParam {
            WhereParam::InteractionsEvery(value)
        }
        pub fn none(value: Vec<interaction::WhereParam>) -> WhereParam {
            WhereParam::InteractionsNone(value)
        }
        pub struct Order(Vec<interaction::OrderByRelationAggregateParam>);
        pub fn order<T: From<Order>>(v: Vec<interaction::OrderByRelationAggregateParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Interactions(v)
            }
        }
        pub struct Fetch(pub interaction::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<interaction::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: interaction::OrderByWithRelationParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: interaction::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Interactions(v)
            }
        }
        pub fn fetch(params: Vec<interaction::WhereParam>) -> Fetch {
            Fetch(interaction::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<interaction::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectInteractions(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<interaction::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<interaction::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectInteractions(params)
        }
        pub fn set(params: Vec<interaction::UniqueWhereParam>) -> SetParam {
            SetParam::SetInteractions(params)
        }
        pub enum Select {
            Select(interaction::ManyArgs, Vec<interaction::SelectParam>),
            Include(interaction::ManyArgs, Vec<interaction::IncludeParam>),
            Fetch(interaction::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Interactions(self)
            }
        }
        impl Select {
            pub fn select(
                args: interaction::ManyArgs,
                nested_selections: Vec<interaction::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: interaction::ManyArgs,
                nested_selections: Vec<interaction::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <interaction::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
        pub enum Include {
            Select(interaction::ManyArgs, Vec<interaction::SelectParam>),
            Include(interaction::ManyArgs, Vec<interaction::IncludeParam>),
            Fetch(interaction::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Interactions(self)
            }
        }
        impl Include {
            pub fn select(
                args: interaction::ManyArgs,
                nested_selections: Vec<interaction::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: interaction::ManyArgs,
                nested_selections: Vec<interaction::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < interaction :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <interaction::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
    }
    pub mod kind {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "kind";
        pub type Type = super::super::ChannelType;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub ChannelType);
        pub fn equals<T: From<Equals>>(value: impl Into<ChannelType>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Kind(_prisma::read_filters::ChannelTypeFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::ChannelTypeFilter,
            Kind,
            {
                fn in_vec(_: Vec<ChannelType>) -> InVec;
                fn not_in_vec(_: Vec<ChannelType>) -> NotInVec;
                fn not(_: ChannelType) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Kind(v)
            }
        }
        pub struct Set(pub ChannelType);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Kind(_prisma::write_params::ChannelTypeParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<ChannelType>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::ChannelTypeParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Kind(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Kind(_prisma::write_params::ChannelTypeParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Kind(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Kind(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Kind(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod messages {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "messages";
        pub type Type = Vec<message::Data>;
        pub type RecursiveSafeType = Type;
        pub fn some(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessagesSome(value)
        }
        pub fn every(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessagesEvery(value)
        }
        pub fn none(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessagesNone(value)
        }
        pub struct Order(Vec<message::OrderByRelationAggregateParam>);
        pub fn order<T: From<Order>>(v: Vec<message::OrderByRelationAggregateParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Messages(v)
            }
        }
        pub struct Fetch(pub message::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<message::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: message::OrderByWithRelationParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: message::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Messages(v)
            }
        }
        pub fn fetch(params: Vec<message::WhereParam>) -> Fetch {
            Fetch(message::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<message::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectMessages(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<message::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<message::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectMessages(params)
        }
        pub fn set(params: Vec<message::UniqueWhereParam>) -> SetParam {
            SetParam::SetMessages(params)
        }
        pub enum Select {
            Select(message::ManyArgs, Vec<message::SelectParam>),
            Include(message::ManyArgs, Vec<message::IncludeParam>),
            Fetch(message::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Messages(self)
            }
        }
        impl Select {
            pub fn select(
                args: message::ManyArgs,
                nested_selections: Vec<message::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: message::ManyArgs,
                nested_selections: Vec<message::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
        pub enum Include {
            Select(message::ManyArgs, Vec<message::SelectParam>),
            Include(message::ManyArgs, Vec<message::IncludeParam>),
            Fetch(message::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Messages(self)
            }
        }
        impl Include {
            pub fn select(
                args: message::ManyArgs,
                nested_selections: Vec<message::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: message::ManyArgs,
                nested_selections: Vec<message::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => {
                        (args.to_graphql().0, {
                            let mut nested_selections = < message :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                            nested_selections.extend(selections.into_iter().map(Into::into));
                            nested_selections
                        })
                    }
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
    }
    pub mod name {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "name";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: impl Into<String>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Name(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Name(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<String>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Name(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Name(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod nsfw {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "nsfw";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Nsfw(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            Nsfw,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Nsfw(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Nsfw(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Nsfw(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Nsfw(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Nsfw(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Nsfw(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Nsfw(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod topic {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "topic";
        pub type Type = Option<String>;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Option<String>);
        pub fn equals<T: From<Equals>>(value: impl Into<Option<String>>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Topic(_prisma::read_filters::StringNullableFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Topic,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Topic(v)
            }
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Topic(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<Option<String>>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Topic(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Topic(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Topic(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Topic(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Topic(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
pub mod channel_category {
    use super::_prisma::*;
    pub const NAME: &str = "ChannelCategory";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(super::_prisma::read_filters::BigIntFilter),
        Name(super::_prisma::read_filters::StringFilter),
        ChannelsSome(Vec<super::channel::WhereParam>),
        ChannelsEvery(Vec<super::channel::WhereParam>),
        ChannelsNone(Vec<super::channel::WhereParam>),
        Deleted(super::_prisma::read_filters::BooleanFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::ChannelsSome(where_params) => (
                    channels::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChannelsEvery(where_params) => (
                    channels::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChannelsNone(where_params) => (
                    channels::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Deleted(value) => (deleted::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i64),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        Id(super::SortOrder),
        Name(super::SortOrder),
        Deleted(super::SortOrder),
        Channels(Vec<super::channel::OrderByRelationAggregateParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(param) => ("id", param.into()),
                Self::Name(param) => ("name", param.into()),
                Self::Deleted(param) => ("deleted", param.into()),
                Self::Channels(param) => (
                    "channels",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {
        Channels(super::channel::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Channels(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        channels::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Name(super::_prisma::write_params::StringParam),
        ConnectChannels(Vec<super::channel::UniqueWhereParam>),
        DisconnectChannels(Vec<super::channel::UniqueWhereParam>),
        SetChannels(Vec<super::channel::UniqueWhereParam>),
        Deleted(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::ConnectChannels(where_params) => (
                    channels::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectChannels(where_params) => (
                    channels::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SetChannels(where_params) => (
                    channels::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                Self::Deleted(value) => (deleted::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Name(super::_prisma::write_params::StringParam),
        Deleted(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => ("id", value.into()),
                Self::Name(value) => ("name", value.into()),
                Self::Deleted(value) => ("deleted", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_channel_category,
        select,
        generated::channel_category,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "name")]
            name: name::Type,
            #[serde(rename = "channels")]
            channels: channels::Type,
            #[serde(rename = "deleted")]
            deleted: deleted::Type,
        },
        [
            (id, Scalar),
            (name, Scalar),
            (channels, Relation(generated::channel, Many)),
            (deleted, Scalar)
        ]
    );
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Channels(channels::Select),
        Deleted(deleted::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Name(data) => data.into(),
                Self::Channels(data) => data.into(),
                Self::Deleted(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_channel_category,
        include,
        generated::channel_category,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "name")]
            name: name::Type,
            #[serde(rename = "channels")]
            channels: channels::Type,
            #[serde(rename = "deleted")]
            deleted: deleted::Type,
        },
        [(channels, Relation(generated::channel, Many))]
    );
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Channels(channels::Include),
        Deleted(deleted::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Name(data) => data.into(),
                Self::Channels(data) => data.into(),
                Self::Deleted(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub id: i64,
        pub name: String,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client
                .channel_category()
                .create(self.id, self.name, self._params)
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params
                .extend([id::set(self.id), name::set(self.name)]);
            self._params
        }
    }
    pub fn create(id: i64, name: String, _params: Vec<SetParam>) -> Create {
        Create { id, name, _params }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub id: i64,
        pub name: String,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client
                .channel_category()
                .create_unchecked(self.id, self.name, self._params)
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params
                .extend([id::set(self.id), name::set(self.name)]);
            self._params
        }
    }
    pub fn create_unchecked(
        id: i64,
        name: String,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked { id, name, _params }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(deleted::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: id::Type,
        #[serde(rename = "name")]
        pub name: name::Type,
        #[serde(rename = "channels")]
        pub channels: Option<channels::RecursiveSafeType>,
        #[serde(rename = "deleted")]
        pub deleted: deleted::Type,
    }
    impl Data {
        pub fn channels(
            &self,
        ) -> Result<&channels::Type, ::prisma_client_rust::RelationNotFetchedError> {
            self.channels
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(channels),
                ))
        }
    }
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_channel_category,
        generated::channel_category,
        struct Data {
            #[serde(rename = "id")]
            pub id: generated::channel_category::id::Type,
            #[serde(rename = "name")]
            pub name: generated::channel_category::name::Type,
            #[serde(rename = "deleted")]
            pub deleted: generated::channel_category::deleted::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _channel_category_filter,
        generated::channel_category,
        [
            (id, Scalar),
            (name, Scalar),
            (channels, Relation(generated::channel, Many)),
            (deleted, Scalar)
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            id: impl Into<i64>,
            name: impl Into<String>,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            let id = id.into();
            let name = name.into();
            _params.extend([id::set(id), name::set(name)]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: impl Into<i64>,
            name: impl Into<String>,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            let id = id.into();
            let name = name.into();
            _params.extend([id::set(id), name::set(name)]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod channels {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "channels";
        pub type Type = Vec<channel::Data>;
        pub type RecursiveSafeType = Type;
        pub fn some(value: Vec<channel::WhereParam>) -> WhereParam {
            WhereParam::ChannelsSome(value)
        }
        pub fn every(value: Vec<channel::WhereParam>) -> WhereParam {
            WhereParam::ChannelsEvery(value)
        }
        pub fn none(value: Vec<channel::WhereParam>) -> WhereParam {
            WhereParam::ChannelsNone(value)
        }
        pub struct Order(Vec<channel::OrderByRelationAggregateParam>);
        pub fn order<T: From<Order>>(v: Vec<channel::OrderByRelationAggregateParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Channels(v)
            }
        }
        pub struct Fetch(pub channel::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<channel::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: channel::OrderByWithRelationParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: channel::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Channels(v)
            }
        }
        pub fn fetch(params: Vec<channel::WhereParam>) -> Fetch {
            Fetch(channel::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<channel::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectChannels(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<channel::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<channel::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectChannels(params)
        }
        pub fn set(params: Vec<channel::UniqueWhereParam>) -> SetParam {
            SetParam::SetChannels(params)
        }
        pub enum Select {
            Select(channel::ManyArgs, Vec<channel::SelectParam>),
            Include(channel::ManyArgs, Vec<channel::IncludeParam>),
            Fetch(channel::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Channels(self)
            }
        }
        impl Select {
            pub fn select(
                args: channel::ManyArgs,
                nested_selections: Vec<channel::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: channel::ManyArgs,
                nested_selections: Vec<channel::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <channel::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
        pub enum Include {
            Select(channel::ManyArgs, Vec<channel::SelectParam>),
            Include(channel::ManyArgs, Vec<channel::IncludeParam>),
            Fetch(channel::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Channels(self)
            }
        }
        impl Include {
            pub fn select(
                args: channel::ManyArgs,
                nested_selections: Vec<channel::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: channel::ManyArgs,
                nested_selections: Vec<channel::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(Into::into).collect(),
                    ),
                    Self::Include(args, selections) => {
                        (args.to_graphql().0, {
                            let mut nested_selections = < channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                            nested_selections.extend(selections.into_iter().map(Into::into));
                            nested_selections
                        })
                    }
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <channel::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
        }
    }
    pub mod deleted {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "deleted";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Deleted(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            Deleted,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Deleted(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Deleted(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Deleted(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Deleted(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Deleted(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Deleted(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Deleted(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::IdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Id(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Id, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Id(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "name";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: impl Into<String>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Name(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Name(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<String>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Name(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Name(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
pub mod command_interaction_data {
    use super::_prisma::*;
    pub const NAME: &str = "CommandInteractionData";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        CommandId(super::_prisma::read_filters::StringFilter),
        CommandName(super::_prisma::read_filters::StringFilter),
        InteractionIs(Vec<super::interaction::WhereParam>),
        InteractionIsNot(Vec<super::interaction::WhereParam>),
        InteractionId(super::_prisma::read_filters::BigIntFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::CommandId(value) => (command_id::NAME, value.into()),
                Self::CommandName(value) => (command_name::NAME, value.into()),
                Self::InteractionIs(where_params) => (
                    interaction::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InteractionIsNot(where_params) => (
                    interaction::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InteractionId(value) => (interaction_id::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        InteractionIdEquals(i64),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::InteractionIdEquals(value) => (
                    "interaction_id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        CommandId(super::SortOrder),
        CommandName(super::SortOrder),
        InteractionId(super::SortOrder),
        Interaction(Vec<super::interaction::OrderByWithRelationParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::CommandId(param) => ("command_id", param.into()),
                Self::CommandName(param) => ("command_name", param.into()),
                Self::InteractionId(param) => ("interaction_id", param.into()),
                Self::Interaction(param) => (
                    "interaction",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {
        Interaction(super::interaction::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Interaction(args) => {
                    let mut selections = < super :: interaction :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(interaction::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        CommandId(super::_prisma::write_params::StringParam),
        CommandName(super::_prisma::write_params::StringParam),
        ConnectInteraction(super::interaction::UniqueWhereParam),
        InteractionId(super::_prisma::write_params::BigIntParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::CommandId(value) => (command_id::NAME, value.into()),
                Self::CommandName(value) => (command_name::NAME, value.into()),
                Self::ConnectInteraction(where_param) => (
                    interaction::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InteractionId(value) => (interaction_id::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        CommandId(super::_prisma::write_params::StringParam),
        CommandName(super::_prisma::write_params::StringParam),
        InteractionId(super::_prisma::write_params::BigIntParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::CommandId(value) => ("command_id", value.into()),
                Self::CommandName(value) => ("command_name", value.into()),
                Self::InteractionId(value) => ("interaction_id", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_command_interaction_data,
        select,
        generated::command_interaction_data,
        struct Data {
            #[serde(rename = "command_id")]
            command_id: command_id::Type,
            #[serde(rename = "command_name")]
            command_name: command_name::Type,
            #[serde(rename = "interaction")]
            interaction: interaction::Type,
            #[serde(rename = "interaction_id")]
            interaction_id: interaction_id::Type,
        },
        [
            (command_id, Scalar),
            (command_name, Scalar),
            (interaction, Relation(generated::interaction, One)),
            (interaction_id, Scalar)
        ]
    );
    pub enum SelectParam {
        CommandId(command_id::Select),
        CommandName(command_name::Select),
        Interaction(interaction::Select),
        InteractionId(interaction_id::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::CommandId(data) => data.into(),
                Self::CommandName(data) => data.into(),
                Self::Interaction(data) => data.into(),
                Self::InteractionId(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_command_interaction_data,
        include,
        generated::command_interaction_data,
        struct Data {
            #[serde(rename = "command_id")]
            command_id: command_id::Type,
            #[serde(rename = "command_name")]
            command_name: command_name::Type,
            #[serde(rename = "interaction")]
            interaction: interaction::Type,
            #[serde(rename = "interaction_id")]
            interaction_id: interaction_id::Type,
        },
        [(interaction, Relation(generated::interaction, One))]
    );
    pub enum IncludeParam {
        CommandId(command_id::Include),
        CommandName(command_name::Include),
        Interaction(interaction::Include),
        InteractionId(interaction_id::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::CommandId(data) => data.into(),
                Self::CommandName(data) => data.into(),
                Self::Interaction(data) => data.into(),
                Self::InteractionId(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub command_id: String,
        pub command_name: String,
        pub interaction: super::interaction::UniqueWhereParam,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client.command_interaction_data().create(
                self.command_id,
                self.command_name,
                self.interaction,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([
                command_id::set(self.command_id),
                command_name::set(self.command_name),
                interaction::connect(self.interaction),
            ]);
            self._params
        }
    }
    pub fn create(
        command_id: String,
        command_name: String,
        interaction: super::interaction::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> Create {
        Create {
            command_id,
            command_name,
            interaction,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub command_id: String,
        pub command_name: String,
        pub interaction_id: i64,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client.command_interaction_data().create_unchecked(
                self.command_id,
                self.command_name,
                self.interaction_id,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([
                command_id::set(self.command_id),
                command_name::set(self.command_name),
                interaction_id::set(self.interaction_id),
            ]);
            self._params
        }
    }
    pub fn create_unchecked(
        command_id: String,
        command_name: String,
        interaction_id: i64,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            command_id,
            command_name,
            interaction_id,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(command_id::NAME),
                ::prisma_client_rust::sel(command_name::NAME),
                ::prisma_client_rust::sel(interaction_id::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "command_id")]
        pub command_id: command_id::Type,
        #[serde(rename = "command_name")]
        pub command_name: command_name::Type,
        #[serde(rename = "interaction")]
        pub interaction: Option<interaction::RecursiveSafeType>,
        #[serde(rename = "interaction_id")]
        pub interaction_id: interaction_id::Type,
    }
    impl Data {
        pub fn interaction(
            &self,
        ) -> Result<&super::interaction::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.interaction
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(interaction),
                ))
                .map(|v| v.as_ref())
        }
    }
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_command_interaction_data,
        generated::command_interaction_data,
        struct Data {
            #[serde(rename = "command_id")]
            pub command_id: generated::command_interaction_data::command_id::Type,
            #[serde(rename = "command_name")]
            pub command_name: generated::command_interaction_data::command_name::Type,
            #[serde(rename = "interaction_id")]
            pub interaction_id: generated::command_interaction_data::interaction_id::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _command_interaction_data_filter,
        generated::command_interaction_data,
        [
            (command_id, Scalar),
            (command_name, Scalar),
            (interaction, Relation(generated::interaction, One)),
            (interaction_id, Scalar)
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            command_id: impl Into<String>,
            command_name: impl Into<String>,
            interaction: super::interaction::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            let command_id = command_id.into();
            let command_name = command_name.into();
            let interaction = interaction.into();
            _params.extend([
                command_id::set(command_id),
                command_name::set(command_name),
                interaction::connect(interaction),
            ]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            command_id: impl Into<String>,
            command_name: impl Into<String>,
            interaction_id: impl Into<i64>,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            let command_id = command_id.into();
            let command_name = command_name.into();
            let interaction_id = interaction_id.into();
            _params.extend([
                command_id::set(command_id),
                command_name::set(command_name),
                interaction_id::set(interaction_id),
            ]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod command_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "command_id";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: impl Into<String>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::CommandId(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            CommandId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::CommandId(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::CommandId(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<String>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::CommandId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CommandId(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::CommandId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CommandId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CommandId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod command_name {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "command_name";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: impl Into<String>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::CommandName(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            CommandName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::CommandName(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::CommandName(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<String>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::CommandName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CommandName(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::CommandName(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CommandName(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CommandName(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod interaction {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "interaction";
        pub type Type = interaction::Data;
        pub type RecursiveSafeType = Box<interaction::Data>;
        pub fn is(value: Vec<interaction::WhereParam>) -> WhereParam {
            WhereParam::InteractionIs(value)
        }
        pub fn is_not(value: Vec<interaction::WhereParam>) -> WhereParam {
            WhereParam::InteractionIsNot(value)
        }
        pub struct Order(Vec<interaction::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<interaction::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Interaction(v)
            }
        }
        pub struct Fetch(pub interaction::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<interaction::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Interaction(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(interaction::UniqueArgs::new())
        }
        pub struct Connect(interaction::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectInteraction(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: interaction::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub enum Select {
            Select(Vec<interaction::SelectParam>),
            Include(Vec<interaction::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Interaction(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<interaction::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<interaction::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <interaction::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        )
                    }
                };
                ::prisma_client_rust::Selection::new("interaction", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<interaction::SelectParam>),
            Include(Vec<interaction::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Interaction(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<interaction::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<interaction::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = < interaction :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <interaction::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        )
                    }
                };
                ::prisma_client_rust::Selection::new("interaction", None, [], selections)
            }
        }
    }
    pub mod interaction_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "interaction_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::InteractionIdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::InteractionId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            InteractionId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::InteractionId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::InteractionId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::InteractionId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::InteractionId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::InteractionId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::InteractionId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::InteractionId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
pub mod interaction {
    use super::_prisma::*;
    pub const NAME: &str = "Interaction";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(super::_prisma::read_filters::BigIntFilter),
        Kind(super::_prisma::read_filters::InteractionTypeFilter),
        Token(super::_prisma::read_filters::StringFilter),
        ApplicationId(super::_prisma::read_filters::BigIntFilter),
        Created(super::_prisma::read_filters::DateTimeFilter),
        Reusable(super::_prisma::read_filters::BooleanFilter),
        ChannelIs(Vec<super::channel::WhereParam>),
        ChannelIsNot(Vec<super::channel::WhereParam>),
        InvokerIs(Vec<super::user::WhereParam>),
        InvokerIsNot(Vec<super::user::WhereParam>),
        ChannelId(super::_prisma::read_filters::BigIntFilter),
        InvokerId(super::_prisma::read_filters::BigIntFilter),
        CommandDataIsNull,
        CommandDataIs(Vec<super::command_interaction_data::WhereParam>),
        CommandDataIsNot(Vec<super::command_interaction_data::WhereParam>),
        CustomId(super::_prisma::read_filters::StringNullableFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Kind(value) => (kind::NAME, value.into()),
                Self::Token(value) => (token::NAME, value.into()),
                Self::ApplicationId(value) => (application_id::NAME, value.into()),
                Self::Created(value) => (created::NAME, value.into()),
                Self::Reusable(value) => (reusable::NAME, value.into()),
                Self::ChannelIs(where_params) => (
                    channel::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChannelIsNot(where_params) => (
                    channel::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InvokerIs(where_params) => (
                    invoker::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InvokerIsNot(where_params) => (
                    invoker::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChannelId(value) => (channel_id::NAME, value.into()),
                Self::InvokerId(value) => (invoker_id::NAME, value.into()),
                Self::CommandDataIsNull => (
                    command_data::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::CommandDataIs(where_params) => (
                    command_data::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CommandDataIsNot(where_params) => (
                    command_data::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CustomId(value) => (custom_id::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i64),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        Id(super::SortOrder),
        Kind(super::SortOrder),
        Token(super::SortOrder),
        ApplicationId(super::SortOrder),
        Created(super::SortOrder),
        Reusable(super::SortOrder),
        ChannelId(super::SortOrder),
        InvokerId(super::SortOrder),
        CustomId(super::SortOrder),
        Channel(Vec<super::channel::OrderByWithRelationParam>),
        Invoker(Vec<super::user::OrderByWithRelationParam>),
        CommandData(Vec<super::command_interaction_data::OrderByWithRelationParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(param) => ("id", param.into()),
                Self::Kind(param) => ("kind", param.into()),
                Self::Token(param) => ("token", param.into()),
                Self::ApplicationId(param) => ("application_id", param.into()),
                Self::Created(param) => ("created", param.into()),
                Self::Reusable(param) => ("reusable", param.into()),
                Self::ChannelId(param) => ("channel_id", param.into()),
                Self::InvokerId(param) => ("invoker_id", param.into()),
                Self::CustomId(param) => ("custom_id", param.into()),
                Self::Channel(param) => (
                    "channel",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::Invoker(param) => (
                    "invoker",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::CommandData(param) => (
                    "command_data",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByRelationAggregateParam {
        _Count(super::SortOrder),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::_Count(param) => ("_count", param.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {
        Channel(super::channel::UniqueArgs),
        Invoker(super::user::UniqueArgs),
        CommandData(super::command_interaction_data::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Channel(args) => {
                    let mut selections = < super :: channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(channel::NAME, None, [], selections)
                }
                Self::Invoker(args) => {
                    let mut selections =
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(invoker::NAME, None, [], selections)
                }
                Self::CommandData(args) => {
                    let mut selections = < super :: command_interaction_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(command_data::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Kind(super::_prisma::write_params::InteractionTypeParam),
        Token(super::_prisma::write_params::StringParam),
        ApplicationId(super::_prisma::write_params::BigIntParam),
        Created(super::_prisma::write_params::DateTimeParam),
        Reusable(super::_prisma::write_params::BooleanParam),
        ConnectChannel(super::channel::UniqueWhereParam),
        ConnectInvoker(super::user::UniqueWhereParam),
        ChannelId(super::_prisma::write_params::BigIntParam),
        InvokerId(super::_prisma::write_params::BigIntParam),
        ConnectCommandData(super::command_interaction_data::UniqueWhereParam),
        DisconnectCommandData,
        CustomId(super::_prisma::write_params::StringNullableParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => (id::NAME, value.into()),
                Self::Kind(value) => (kind::NAME, value.into()),
                Self::Token(value) => (token::NAME, value.into()),
                Self::ApplicationId(value) => (application_id::NAME, value.into()),
                Self::Created(value) => (created::NAME, value.into()),
                Self::Reusable(value) => (reusable::NAME, value.into()),
                Self::ConnectChannel(where_param) => (
                    channel::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ConnectInvoker(where_param) => (
                    invoker::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChannelId(value) => (channel_id::NAME, value.into()),
                Self::InvokerId(value) => (invoker_id::NAME, value.into()),
                Self::ConnectCommandData(where_param) => (
                    command_data::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisconnectCommandData => (
                    command_data::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                Self::CustomId(value) => (custom_id::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        Id(super::_prisma::write_params::BigIntParam),
        Kind(super::_prisma::write_params::InteractionTypeParam),
        Token(super::_prisma::write_params::StringParam),
        ApplicationId(super::_prisma::write_params::BigIntParam),
        Created(super::_prisma::write_params::DateTimeParam),
        Reusable(super::_prisma::write_params::BooleanParam),
        ChannelId(super::_prisma::write_params::BigIntParam),
        InvokerId(super::_prisma::write_params::BigIntParam),
        CustomId(super::_prisma::write_params::StringNullableParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => ("id", value.into()),
                Self::Kind(value) => ("kind", value.into()),
                Self::Token(value) => ("token", value.into()),
                Self::ApplicationId(value) => ("application_id", value.into()),
                Self::Created(value) => ("created", value.into()),
                Self::Reusable(value) => ("reusable", value.into()),
                Self::ChannelId(value) => ("channel_id", value.into()),
                Self::InvokerId(value) => ("invoker_id", value.into()),
                Self::CustomId(value) => ("custom_id", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_interaction,
        select,
        generated::interaction,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "kind")]
            kind: kind::Type,
            #[serde(rename = "token")]
            token: token::Type,
            #[serde(rename = "application_id")]
            application_id: application_id::Type,
            #[serde(rename = "created")]
            created: created::Type,
            #[serde(rename = "reusable")]
            reusable: reusable::Type,
            #[serde(rename = "channel")]
            channel: channel::Type,
            #[serde(rename = "invoker")]
            invoker: invoker::Type,
            #[serde(rename = "channel_id")]
            channel_id: channel_id::Type,
            #[serde(rename = "invoker_id")]
            invoker_id: invoker_id::Type,
            #[serde(rename = "command_data")]
            command_data: command_data::Type,
            #[serde(rename = "custom_id")]
            custom_id: custom_id::Type,
        },
        [
            (id, Scalar),
            (kind, Scalar),
            (token, Scalar),
            (application_id, Scalar),
            (created, Scalar),
            (reusable, Scalar),
            (channel, Relation(generated::channel, One)),
            (invoker, Relation(generated::user, One)),
            (channel_id, Scalar),
            (invoker_id, Scalar),
            (
                command_data,
                Relation(generated::command_interaction_data, One)
            ),
            (custom_id, Scalar)
        ]
    );
    pub enum SelectParam {
        Id(id::Select),
        Kind(kind::Select),
        Token(token::Select),
        ApplicationId(application_id::Select),
        Created(created::Select),
        Reusable(reusable::Select),
        Channel(channel::Select),
        Invoker(invoker::Select),
        ChannelId(channel_id::Select),
        InvokerId(invoker_id::Select),
        CommandData(command_data::Select),
        CustomId(custom_id::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Kind(data) => data.into(),
                Self::Token(data) => data.into(),
                Self::ApplicationId(data) => data.into(),
                Self::Created(data) => data.into(),
                Self::Reusable(data) => data.into(),
                Self::Channel(data) => data.into(),
                Self::Invoker(data) => data.into(),
                Self::ChannelId(data) => data.into(),
                Self::InvokerId(data) => data.into(),
                Self::CommandData(data) => data.into(),
                Self::CustomId(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_interaction,
        include,
        generated::interaction,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "kind")]
            kind: kind::Type,
            #[serde(rename = "token")]
            token: token::Type,
            #[serde(rename = "application_id")]
            application_id: application_id::Type,
            #[serde(rename = "created")]
            created: created::Type,
            #[serde(rename = "reusable")]
            reusable: reusable::Type,
            #[serde(rename = "channel")]
            channel: channel::Type,
            #[serde(rename = "invoker")]
            invoker: invoker::Type,
            #[serde(rename = "channel_id")]
            channel_id: channel_id::Type,
            #[serde(rename = "invoker_id")]
            invoker_id: invoker_id::Type,
            #[serde(rename = "command_data")]
            command_data: command_data::Type,
            #[serde(rename = "custom_id")]
            custom_id: custom_id::Type,
        },
        [
            (channel, Relation(generated::channel, One)),
            (invoker, Relation(generated::user, One)),
            (
                command_data,
                Relation(generated::command_interaction_data, One)
            )
        ]
    );
    pub enum IncludeParam {
        Id(id::Include),
        Kind(kind::Include),
        Token(token::Include),
        ApplicationId(application_id::Include),
        Created(created::Include),
        Reusable(reusable::Include),
        Channel(channel::Include),
        Invoker(invoker::Include),
        ChannelId(channel_id::Include),
        InvokerId(invoker_id::Include),
        CommandData(command_data::Include),
        CustomId(custom_id::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Kind(data) => data.into(),
                Self::Token(data) => data.into(),
                Self::ApplicationId(data) => data.into(),
                Self::Created(data) => data.into(),
                Self::Reusable(data) => data.into(),
                Self::Channel(data) => data.into(),
                Self::Invoker(data) => data.into(),
                Self::ChannelId(data) => data.into(),
                Self::InvokerId(data) => data.into(),
                Self::CommandData(data) => data.into(),
                Self::CustomId(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub id: i64,
        pub kind: super::InteractionType,
        pub token: String,
        pub application_id: i64,
        pub channel: super::channel::UniqueWhereParam,
        pub invoker: super::user::UniqueWhereParam,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client.interaction().create(
                self.id,
                self.kind,
                self.token,
                self.application_id,
                self.channel,
                self.invoker,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([
                id::set(self.id),
                kind::set(self.kind),
                token::set(self.token),
                application_id::set(self.application_id),
                channel::connect(self.channel),
                invoker::connect(self.invoker),
            ]);
            self._params
        }
    }
    pub fn create(
        id: i64,
        kind: super::InteractionType,
        token: String,
        application_id: i64,
        channel: super::channel::UniqueWhereParam,
        invoker: super::user::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> Create {
        Create {
            id,
            kind,
            token,
            application_id,
            channel,
            invoker,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub id: i64,
        pub kind: super::InteractionType,
        pub token: String,
        pub application_id: i64,
        pub channel_id: i64,
        pub invoker_id: i64,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client.interaction().create_unchecked(
                self.id,
                self.kind,
                self.token,
                self.application_id,
                self.channel_id,
                self.invoker_id,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([
                id::set(self.id),
                kind::set(self.kind),
                token::set(self.token),
                application_id::set(self.application_id),
                channel_id::set(self.channel_id),
                invoker_id::set(self.invoker_id),
            ]);
            self._params
        }
    }
    pub fn create_unchecked(
        id: i64,
        kind: super::InteractionType,
        token: String,
        application_id: i64,
        channel_id: i64,
        invoker_id: i64,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            id,
            kind,
            token,
            application_id,
            channel_id,
            invoker_id,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(kind::NAME),
                ::prisma_client_rust::sel(token::NAME),
                ::prisma_client_rust::sel(application_id::NAME),
                ::prisma_client_rust::sel(created::NAME),
                ::prisma_client_rust::sel(reusable::NAME),
                ::prisma_client_rust::sel(channel_id::NAME),
                ::prisma_client_rust::sel(invoker_id::NAME),
                ::prisma_client_rust::sel(custom_id::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: id::Type,
        #[serde(rename = "kind")]
        pub kind: kind::Type,
        #[serde(rename = "token")]
        pub token: token::Type,
        #[serde(rename = "application_id")]
        pub application_id: application_id::Type,
        #[serde(rename = "created")]
        pub created: created::Type,
        #[serde(rename = "reusable")]
        pub reusable: reusable::Type,
        #[serde(rename = "channel")]
        pub channel: Option<channel::RecursiveSafeType>,
        #[serde(rename = "invoker")]
        pub invoker: Option<invoker::RecursiveSafeType>,
        #[serde(rename = "channel_id")]
        pub channel_id: channel_id::Type,
        #[serde(rename = "invoker_id")]
        pub invoker_id: invoker_id::Type,
        #[serde(
            rename = "command_data",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub command_data: Option<command_data::RecursiveSafeType>,
        #[serde(rename = "custom_id")]
        pub custom_id: custom_id::Type,
    }
    impl Data {
        pub fn channel(
            &self,
        ) -> Result<&super::channel::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.channel
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(channel),
                ))
                .map(|v| v.as_ref())
        }
        pub fn invoker(
            &self,
        ) -> Result<&super::user::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.invoker
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(invoker),
                ))
                .map(|v| v.as_ref())
        }
        pub fn command_data(
            &self,
        ) -> Result<
            Option<&super::command_interaction_data::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.command_data
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(command_data),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_interaction,
        generated::interaction,
        struct Data {
            #[serde(rename = "id")]
            pub id: generated::interaction::id::Type,
            #[serde(rename = "kind")]
            pub kind: generated::interaction::kind::Type,
            #[serde(rename = "token")]
            pub token: generated::interaction::token::Type,
            #[serde(rename = "application_id")]
            pub application_id: generated::interaction::application_id::Type,
            #[serde(rename = "created")]
            pub created: generated::interaction::created::Type,
            #[serde(rename = "reusable")]
            pub reusable: generated::interaction::reusable::Type,
            #[serde(rename = "channel_id")]
            pub channel_id: generated::interaction::channel_id::Type,
            #[serde(rename = "invoker_id")]
            pub invoker_id: generated::interaction::invoker_id::Type,
            #[serde(rename = "custom_id")]
            #[serde(default, with = "::prisma_client_rust::serde::double_option")]
            pub custom_id: generated::interaction::custom_id::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _interaction_filter,
        generated::interaction,
        [
            (id, Scalar),
            (kind, Scalar),
            (token, Scalar),
            (application_id, Scalar),
            (created, Scalar),
            (reusable, Scalar),
            (channel, Relation(generated::channel, One)),
            (invoker, Relation(generated::user, One)),
            (channel_id, Scalar),
            (invoker_id, Scalar),
            (
                command_data,
                Relation(generated::command_interaction_data, One)
            ),
            (custom_id, Scalar)
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            id: impl Into<i64>,
            kind: impl Into<super::InteractionType>,
            token: impl Into<String>,
            application_id: impl Into<i64>,
            channel: super::channel::UniqueWhereParam,
            invoker: super::user::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            let id = id.into();
            let kind = kind.into();
            let token = token.into();
            let application_id = application_id.into();
            let channel = channel.into();
            let invoker = invoker.into();
            _params.extend([
                id::set(id),
                kind::set(kind),
                token::set(token),
                application_id::set(application_id),
                channel::connect(channel),
                invoker::connect(invoker),
            ]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: impl Into<i64>,
            kind: impl Into<super::InteractionType>,
            token: impl Into<String>,
            application_id: impl Into<i64>,
            channel_id: impl Into<i64>,
            invoker_id: impl Into<i64>,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            let id = id.into();
            let kind = kind.into();
            let token = token.into();
            let application_id = application_id.into();
            let channel_id = channel_id.into();
            let invoker_id = invoker_id.into();
            _params.extend([
                id::set(id),
                kind::set(kind),
                token::set(token),
                application_id::set(application_id),
                channel_id::set(channel_id),
                invoker_id::set(invoker_id),
            ]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod _count {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "_count";
        pub struct Order(super::SortOrder);
        pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByRelationAggregateParam {
            fn from(Order(v): Order) -> Self {
                Self::_Count(v)
            }
        }
    }
    pub mod application_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "application_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::ApplicationId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            ApplicationId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::ApplicationId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::ApplicationId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ApplicationId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ApplicationId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ApplicationId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ApplicationId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ApplicationId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod channel {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "channel";
        pub type Type = channel::Data;
        pub type RecursiveSafeType = Box<channel::Data>;
        pub fn is(value: Vec<channel::WhereParam>) -> WhereParam {
            WhereParam::ChannelIs(value)
        }
        pub fn is_not(value: Vec<channel::WhereParam>) -> WhereParam {
            WhereParam::ChannelIsNot(value)
        }
        pub struct Order(Vec<channel::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<channel::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Channel(v)
            }
        }
        pub struct Fetch(pub channel::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<channel::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Channel(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(channel::UniqueArgs::new())
        }
        pub struct Connect(channel::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectChannel(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: channel::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub enum Select {
            Select(Vec<channel::SelectParam>),
            Include(Vec<channel::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Channel(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<channel::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<channel::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <channel::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("channel", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<channel::SelectParam>),
            Include(Vec<channel::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Channel(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<channel::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<channel::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <channel::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <channel::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("channel", None, [], selections)
            }
        }
    }
    pub mod channel_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "channel_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            ChannelId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::ChannelId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::ChannelId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ChannelId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ChannelId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ChannelId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChannelId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChannelId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod command_data {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "command_data";
        pub type Type = Option<command_interaction_data::Data>;
        pub type RecursiveSafeType = Option<Box<command_interaction_data::Data>>;
        pub fn is(value: Vec<command_interaction_data::WhereParam>) -> WhereParam {
            WhereParam::CommandDataIs(value)
        }
        pub fn is_not(value: Vec<command_interaction_data::WhereParam>) -> WhereParam {
            WhereParam::CommandDataIsNot(value)
        }
        pub struct Order(Vec<command_interaction_data::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(
            v: Vec<command_interaction_data::OrderByWithRelationParam>,
        ) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::CommandData(v)
            }
        }
        pub struct Fetch(pub command_interaction_data::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<command_interaction_data::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::CommandData(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(command_interaction_data::UniqueArgs::new())
        }
        pub struct Connect(command_interaction_data::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectCommandData(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: command_interaction_data::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectCommandData
        }
        pub fn is_null() -> WhereParam {
            WhereParam::CommandDataIsNull
        }
        pub enum Select {
            Select(Vec<command_interaction_data::SelectParam>),
            Include(Vec<command_interaction_data::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CommandData(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<command_interaction_data::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<command_interaction_data::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < command_interaction_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("command_data", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<command_interaction_data::SelectParam>),
            Include(Vec<command_interaction_data::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CommandData(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<command_interaction_data::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<command_interaction_data::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < command_interaction_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < command_interaction_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("command_data", None, [], selections)
            }
        }
    }
    pub mod created {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "created";
        pub type Type =
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>;
        pub type RecursiveSafeType = Type;
        pub struct Equals(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        pub fn equals<T: From<Equals>>(
            value: impl Into<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Created(_prisma::read_filters::DateTimeFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            Created,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Created(v)
            }
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Created(_prisma::write_params::DateTimeParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(
            value: impl Into<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Created(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Created(_prisma::write_params::DateTimeParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Created(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Created(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Created(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod custom_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "custom_id";
        pub type Type = Option<String>;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Option<String>);
        pub fn equals<T: From<Equals>>(value: impl Into<Option<String>>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::CustomId(_prisma::read_filters::StringNullableFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            CustomId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::CustomId(v)
            }
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::CustomId(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<Option<String>>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::CustomId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CustomId(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::CustomId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CustomId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CustomId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::IdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Id(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Id, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Id(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod invoker {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "invoker";
        pub type Type = user::Data;
        pub type RecursiveSafeType = Box<user::Data>;
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::InvokerIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::InvokerIsNot(value)
        }
        pub struct Order(Vec<user::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<user::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Invoker(v)
            }
        }
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Invoker(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectInvoker(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Invoker(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("invoker", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Invoker(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("invoker", None, [], selections)
            }
        }
    }
    pub mod invoker_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "invoker_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::InvokerId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            InvokerId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::InvokerId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::InvokerId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::InvokerId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::InvokerId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::InvokerId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::InvokerId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::InvokerId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod kind {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "kind";
        pub type Type = super::super::InteractionType;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub InteractionType);
        pub fn equals<T: From<Equals>>(value: impl Into<InteractionType>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Kind(_prisma::read_filters::InteractionTypeFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::InteractionTypeFilter,
            Kind,
            {
                fn in_vec(_: Vec<InteractionType>) -> InVec;
                fn not_in_vec(_: Vec<InteractionType>) -> NotInVec;
                fn not(_: InteractionType) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Kind(v)
            }
        }
        pub struct Set(pub InteractionType);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Kind(_prisma::write_params::InteractionTypeParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<InteractionType>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::InteractionTypeParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Kind(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Kind(_prisma::write_params::InteractionTypeParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Kind(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Kind(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Kind(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod reusable {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "reusable";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Reusable(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            Reusable,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Reusable(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Reusable(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Reusable(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Reusable(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Reusable(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Reusable(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Reusable(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod token {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "token";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: impl Into<String>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Token(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Token,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Token(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Token(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<String>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Token(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Token(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Token(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Token(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Token(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
pub mod impersonated_message_data {
    use super::_prisma::*;
    pub const NAME: &str = "ImpersonatedMessageData";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        SourceIs(Vec<super::message::WhereParam>),
        SourceIsNot(Vec<super::message::WhereParam>),
        SourceId(super::_prisma::read_filters::BigIntFilter),
        FakeAuthorIs(Vec<super::user::WhereParam>),
        FakeAuthorIsNot(Vec<super::user::WhereParam>),
        FakeAuthorId(super::_prisma::read_filters::BigIntFilter),
        FakeMessageId(super::_prisma::read_filters::BigIntFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::SourceIs(where_params) => (
                    source::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SourceIsNot(where_params) => (
                    source::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SourceId(value) => (source_id::NAME, value.into()),
                Self::FakeAuthorIs(where_params) => (
                    fake_author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FakeAuthorIsNot(where_params) => (
                    fake_author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FakeAuthorId(value) => (fake_author_id::NAME, value.into()),
                Self::FakeMessageId(value) => (fake_message_id::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        SourceIdEquals(i64),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::SourceIdEquals(value) => (
                    "source_id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        SourceId(super::SortOrder),
        FakeAuthorId(super::SortOrder),
        FakeMessageId(super::SortOrder),
        Source(Vec<super::message::OrderByWithRelationParam>),
        FakeAuthor(Vec<super::user::OrderByWithRelationParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::SourceId(param) => ("source_id", param.into()),
                Self::FakeAuthorId(param) => ("fake_author_id", param.into()),
                Self::FakeMessageId(param) => ("fake_message_id", param.into()),
                Self::Source(param) => (
                    "source",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
                Self::FakeAuthor(param) => (
                    "fake_author",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByRelationAggregateParam {
        _Count(super::SortOrder),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::_Count(param) => ("_count", param.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {
        Source(super::message::UniqueArgs),
        FakeAuthor(super::user::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Source(args) => {
                    let mut selections = < super :: message :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(source::NAME, None, [], selections)
                }
                Self::FakeAuthor(args) => {
                    let mut selections =
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(fake_author::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        ConnectSource(super::message::UniqueWhereParam),
        SourceId(super::_prisma::write_params::BigIntParam),
        ConnectFakeAuthor(super::user::UniqueWhereParam),
        FakeAuthorId(super::_prisma::write_params::BigIntParam),
        FakeMessageId(super::_prisma::write_params::BigIntParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::ConnectSource(where_param) => (
                    source::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SourceId(value) => (source_id::NAME, value.into()),
                Self::ConnectFakeAuthor(where_param) => (
                    fake_author::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FakeAuthorId(value) => (fake_author_id::NAME, value.into()),
                Self::FakeMessageId(value) => (fake_message_id::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        SourceId(super::_prisma::write_params::BigIntParam),
        FakeAuthorId(super::_prisma::write_params::BigIntParam),
        FakeMessageId(super::_prisma::write_params::BigIntParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::SourceId(value) => ("source_id", value.into()),
                Self::FakeAuthorId(value) => ("fake_author_id", value.into()),
                Self::FakeMessageId(value) => ("fake_message_id", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_impersonated_message_data,
        select,
        generated::impersonated_message_data,
        struct Data {
            #[serde(rename = "source")]
            source: source::Type,
            #[serde(rename = "source_id")]
            source_id: source_id::Type,
            #[serde(rename = "fake_author")]
            fake_author: fake_author::Type,
            #[serde(rename = "fake_author_id")]
            fake_author_id: fake_author_id::Type,
            #[serde(rename = "fake_message_id")]
            fake_message_id: fake_message_id::Type,
        },
        [
            (source, Relation(generated::message, One)),
            (source_id, Scalar),
            (fake_author, Relation(generated::user, One)),
            (fake_author_id, Scalar),
            (fake_message_id, Scalar)
        ]
    );
    pub enum SelectParam {
        Source(source::Select),
        SourceId(source_id::Select),
        FakeAuthor(fake_author::Select),
        FakeAuthorId(fake_author_id::Select),
        FakeMessageId(fake_message_id::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Source(data) => data.into(),
                Self::SourceId(data) => data.into(),
                Self::FakeAuthor(data) => data.into(),
                Self::FakeAuthorId(data) => data.into(),
                Self::FakeMessageId(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_impersonated_message_data,
        include,
        generated::impersonated_message_data,
        struct Data {
            #[serde(rename = "source")]
            source: source::Type,
            #[serde(rename = "source_id")]
            source_id: source_id::Type,
            #[serde(rename = "fake_author")]
            fake_author: fake_author::Type,
            #[serde(rename = "fake_author_id")]
            fake_author_id: fake_author_id::Type,
            #[serde(rename = "fake_message_id")]
            fake_message_id: fake_message_id::Type,
        },
        [
            (source, Relation(generated::message, One)),
            (fake_author, Relation(generated::user, One))
        ]
    );
    pub enum IncludeParam {
        Source(source::Include),
        SourceId(source_id::Include),
        FakeAuthor(fake_author::Include),
        FakeAuthorId(fake_author_id::Include),
        FakeMessageId(fake_message_id::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Source(data) => data.into(),
                Self::SourceId(data) => data.into(),
                Self::FakeAuthor(data) => data.into(),
                Self::FakeAuthorId(data) => data.into(),
                Self::FakeMessageId(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub source: super::message::UniqueWhereParam,
        pub fake_author: super::user::UniqueWhereParam,
        pub fake_message_id: i64,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client.impersonated_message_data().create(
                self.source,
                self.fake_author,
                self.fake_message_id,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([
                source::connect(self.source),
                fake_author::connect(self.fake_author),
                fake_message_id::set(self.fake_message_id),
            ]);
            self._params
        }
    }
    pub fn create(
        source: super::message::UniqueWhereParam,
        fake_author: super::user::UniqueWhereParam,
        fake_message_id: i64,
        _params: Vec<SetParam>,
    ) -> Create {
        Create {
            source,
            fake_author,
            fake_message_id,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub source_id: i64,
        pub fake_author_id: i64,
        pub fake_message_id: i64,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client.impersonated_message_data().create_unchecked(
                self.source_id,
                self.fake_author_id,
                self.fake_message_id,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([
                source_id::set(self.source_id),
                fake_author_id::set(self.fake_author_id),
                fake_message_id::set(self.fake_message_id),
            ]);
            self._params
        }
    }
    pub fn create_unchecked(
        source_id: i64,
        fake_author_id: i64,
        fake_message_id: i64,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            source_id,
            fake_author_id,
            fake_message_id,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(source_id::NAME),
                ::prisma_client_rust::sel(fake_author_id::NAME),
                ::prisma_client_rust::sel(fake_message_id::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "source")]
        pub source: Option<source::RecursiveSafeType>,
        #[serde(rename = "source_id")]
        pub source_id: source_id::Type,
        #[serde(rename = "fake_author")]
        pub fake_author: Option<fake_author::RecursiveSafeType>,
        #[serde(rename = "fake_author_id")]
        pub fake_author_id: fake_author_id::Type,
        #[serde(rename = "fake_message_id")]
        pub fake_message_id: fake_message_id::Type,
    }
    impl Data {
        pub fn source(
            &self,
        ) -> Result<&super::message::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.source
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(source),
                ))
                .map(|v| v.as_ref())
        }
        pub fn fake_author(
            &self,
        ) -> Result<&super::user::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.fake_author
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(fake_author),
                ))
                .map(|v| v.as_ref())
        }
    }
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_impersonated_message_data,
        generated::impersonated_message_data,
        struct Data {
            #[serde(rename = "source_id")]
            pub source_id: generated::impersonated_message_data::source_id::Type,
            #[serde(rename = "fake_author_id")]
            pub fake_author_id: generated::impersonated_message_data::fake_author_id::Type,
            #[serde(rename = "fake_message_id")]
            pub fake_message_id: generated::impersonated_message_data::fake_message_id::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _impersonated_message_data_filter,
        generated::impersonated_message_data,
        [
            (source, Relation(generated::message, One)),
            (source_id, Scalar),
            (fake_author, Relation(generated::user, One)),
            (fake_author_id, Scalar),
            (fake_message_id, Scalar)
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            source: super::message::UniqueWhereParam,
            fake_author: super::user::UniqueWhereParam,
            fake_message_id: impl Into<i64>,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            let source = source.into();
            let fake_author = fake_author.into();
            let fake_message_id = fake_message_id.into();
            _params.extend([
                source::connect(source),
                fake_author::connect(fake_author),
                fake_message_id::set(fake_message_id),
            ]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            source_id: impl Into<i64>,
            fake_author_id: impl Into<i64>,
            fake_message_id: impl Into<i64>,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            let source_id = source_id.into();
            let fake_author_id = fake_author_id.into();
            let fake_message_id = fake_message_id.into();
            _params.extend([
                source_id::set(source_id),
                fake_author_id::set(fake_author_id),
                fake_message_id::set(fake_message_id),
            ]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod _count {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "_count";
        pub struct Order(super::SortOrder);
        pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByRelationAggregateParam {
            fn from(Order(v): Order) -> Self {
                Self::_Count(v)
            }
        }
    }
    pub mod fake_author {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "fake_author";
        pub type Type = user::Data;
        pub type RecursiveSafeType = Box<user::Data>;
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::FakeAuthorIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::FakeAuthorIsNot(value)
        }
        pub struct Order(Vec<user::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<user::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::FakeAuthor(v)
            }
        }
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::FakeAuthor(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectFakeAuthor(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FakeAuthor(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("fake_author", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FakeAuthor(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("fake_author", None, [], selections)
            }
        }
    }
    pub mod fake_author_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "fake_author_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::FakeAuthorId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            FakeAuthorId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::FakeAuthorId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::FakeAuthorId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FakeAuthorId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FakeAuthorId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FakeAuthorId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FakeAuthorId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FakeAuthorId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod fake_message_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "fake_message_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::FakeMessageId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            FakeMessageId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::FakeMessageId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::FakeMessageId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FakeMessageId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FakeMessageId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FakeMessageId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FakeMessageId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FakeMessageId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "source";
        pub type Type = message::Data;
        pub type RecursiveSafeType = Box<message::Data>;
        pub fn is(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::SourceIs(value)
        }
        pub fn is_not(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::SourceIsNot(value)
        }
        pub struct Order(Vec<message::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<message::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Source(v)
            }
        }
        pub struct Fetch(pub message::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<message::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Source(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(message::UniqueArgs::new())
        }
        pub struct Connect(message::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSource(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: message::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub enum Select {
            Select(Vec<message::SelectParam>),
            Include(Vec<message::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Source(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<message::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<message::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("source", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<message::SelectParam>),
            Include(Vec<message::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Source(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<message::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<message::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("source", None, [], selections)
            }
        }
    }
    pub mod source_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "source_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::SourceIdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::SourceId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            SourceId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::SourceId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SourceId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SourceId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SourceId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SourceId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SourceId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SourceId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
pub mod news_in_chat {
    use super::_prisma::*;
    pub const NAME: &str = "NewsInChat";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        SourceIs(Vec<super::message::WhereParam>),
        SourceIsNot(Vec<super::message::WhereParam>),
        SourceId(super::_prisma::read_filters::BigIntFilter),
        FakeMessageId(super::_prisma::read_filters::BigIntFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::SourceIs(where_params) => (
                    source::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SourceIsNot(where_params) => (
                    source::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SourceId(value) => (source_id::NAME, value.into()),
                Self::FakeMessageId(value) => (fake_message_id::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        SourceIdEquals(i64),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::SourceIdEquals(value) => (
                    "source_id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        SourceId(super::SortOrder),
        FakeMessageId(super::SortOrder),
        Source(Vec<super::message::OrderByWithRelationParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::SourceId(param) => ("source_id", param.into()),
                Self::FakeMessageId(param) => ("fake_message_id", param.into()),
                Self::Source(param) => (
                    "source",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByRelationAggregateParam {
        _Count(super::SortOrder),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::_Count(param) => ("_count", param.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {
        Source(super::message::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Source(args) => {
                    let mut selections = < super :: message :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(source::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        ConnectSource(super::message::UniqueWhereParam),
        SourceId(super::_prisma::write_params::BigIntParam),
        FakeMessageId(super::_prisma::write_params::BigIntParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::ConnectSource(where_param) => (
                    source::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SourceId(value) => (source_id::NAME, value.into()),
                Self::FakeMessageId(value) => (fake_message_id::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        SourceId(super::_prisma::write_params::BigIntParam),
        FakeMessageId(super::_prisma::write_params::BigIntParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::SourceId(value) => ("source_id", value.into()),
                Self::FakeMessageId(value) => ("fake_message_id", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_news_in_chat,
        select,
        generated::news_in_chat,
        struct Data {
            #[serde(rename = "source")]
            source: source::Type,
            #[serde(rename = "source_id")]
            source_id: source_id::Type,
            #[serde(rename = "fake_message_id")]
            fake_message_id: fake_message_id::Type,
        },
        [
            (source, Relation(generated::message, One)),
            (source_id, Scalar),
            (fake_message_id, Scalar)
        ]
    );
    pub enum SelectParam {
        Source(source::Select),
        SourceId(source_id::Select),
        FakeMessageId(fake_message_id::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Source(data) => data.into(),
                Self::SourceId(data) => data.into(),
                Self::FakeMessageId(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_news_in_chat,
        include,
        generated::news_in_chat,
        struct Data {
            #[serde(rename = "source")]
            source: source::Type,
            #[serde(rename = "source_id")]
            source_id: source_id::Type,
            #[serde(rename = "fake_message_id")]
            fake_message_id: fake_message_id::Type,
        },
        [(source, Relation(generated::message, One))]
    );
    pub enum IncludeParam {
        Source(source::Include),
        SourceId(source_id::Include),
        FakeMessageId(fake_message_id::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Source(data) => data.into(),
                Self::SourceId(data) => data.into(),
                Self::FakeMessageId(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub source: super::message::UniqueWhereParam,
        pub fake_message_id: i64,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client
                .news_in_chat()
                .create(self.source, self.fake_message_id, self._params)
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([
                source::connect(self.source),
                fake_message_id::set(self.fake_message_id),
            ]);
            self._params
        }
    }
    pub fn create(
        source: super::message::UniqueWhereParam,
        fake_message_id: i64,
        _params: Vec<SetParam>,
    ) -> Create {
        Create {
            source,
            fake_message_id,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub source_id: i64,
        pub fake_message_id: i64,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client.news_in_chat().create_unchecked(
                self.source_id,
                self.fake_message_id,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([
                source_id::set(self.source_id),
                fake_message_id::set(self.fake_message_id),
            ]);
            self._params
        }
    }
    pub fn create_unchecked(
        source_id: i64,
        fake_message_id: i64,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            source_id,
            fake_message_id,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(source_id::NAME),
                ::prisma_client_rust::sel(fake_message_id::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "source")]
        pub source: Option<source::RecursiveSafeType>,
        #[serde(rename = "source_id")]
        pub source_id: source_id::Type,
        #[serde(rename = "fake_message_id")]
        pub fake_message_id: fake_message_id::Type,
    }
    impl Data {
        pub fn source(
            &self,
        ) -> Result<&super::message::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.source
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(source),
                ))
                .map(|v| v.as_ref())
        }
    }
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_news_in_chat,
        generated::news_in_chat,
        struct Data {
            #[serde(rename = "source_id")]
            pub source_id: generated::news_in_chat::source_id::Type,
            #[serde(rename = "fake_message_id")]
            pub fake_message_id: generated::news_in_chat::fake_message_id::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _news_in_chat_filter,
        generated::news_in_chat,
        [
            (source, Relation(generated::message, One)),
            (source_id, Scalar),
            (fake_message_id, Scalar)
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            source: super::message::UniqueWhereParam,
            fake_message_id: impl Into<i64>,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            let source = source.into();
            let fake_message_id = fake_message_id.into();
            _params.extend([
                source::connect(source),
                fake_message_id::set(fake_message_id),
            ]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            source_id: impl Into<i64>,
            fake_message_id: impl Into<i64>,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            let source_id = source_id.into();
            let fake_message_id = fake_message_id.into();
            _params.extend([
                source_id::set(source_id),
                fake_message_id::set(fake_message_id),
            ]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod _count {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "_count";
        pub struct Order(super::SortOrder);
        pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByRelationAggregateParam {
            fn from(Order(v): Order) -> Self {
                Self::_Count(v)
            }
        }
    }
    pub mod fake_message_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "fake_message_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::FakeMessageId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            FakeMessageId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::FakeMessageId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::FakeMessageId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FakeMessageId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FakeMessageId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FakeMessageId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FakeMessageId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FakeMessageId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "source";
        pub type Type = message::Data;
        pub type RecursiveSafeType = Box<message::Data>;
        pub fn is(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::SourceIs(value)
        }
        pub fn is_not(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::SourceIsNot(value)
        }
        pub struct Order(Vec<message::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<message::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Source(v)
            }
        }
        pub struct Fetch(pub message::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<message::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Source(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(message::UniqueArgs::new())
        }
        pub struct Connect(message::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSource(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: message::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub enum Select {
            Select(Vec<message::SelectParam>),
            Include(Vec<message::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Source(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<message::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<message::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("source", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<message::SelectParam>),
            Include(Vec<message::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Source(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<message::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<message::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("source", None, [], selections)
            }
        }
    }
    pub mod source_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "source_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::SourceIdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::SourceId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            SourceId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::SourceId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SourceId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SourceId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SourceId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SourceId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SourceId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SourceId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
pub mod logless_roles {
    use super::_prisma::*;
    pub const NAME: &str = "LoglessRoles";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(super::_prisma::read_filters::BigIntFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i64),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        Id(super::SortOrder),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(param) => ("id", param.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        Id(super::_prisma::write_params::BigIntParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => (id::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        Id(super::_prisma::write_params::BigIntParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => ("id", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_logless_roles,
        select,
        generated::logless_roles,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
        },
        [(id, Scalar)]
    );
    pub enum SelectParam {
        Id(id::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_logless_roles,
        include,
        generated::logless_roles,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
        },
        []
    );
    pub enum IncludeParam {
        Id(id::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub id: i64,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client.logless_roles().create(self.id, self._params)
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([id::set(self.id)]);
            self._params
        }
    }
    pub fn create(id: i64, _params: Vec<SetParam>) -> Create {
        Create { id, _params }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub id: i64,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client
                .logless_roles()
                .create_unchecked(self.id, self._params)
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([id::set(self.id)]);
            self._params
        }
    }
    pub fn create_unchecked(id: i64, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
        CreateUnchecked { id, _params }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![::prisma_client_rust::sel(id::NAME)]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: id::Type,
    }
    impl Data {}
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_logless_roles,
        generated::logless_roles,
        struct Data {
            #[serde(rename = "id")]
            pub id: generated::logless_roles::id::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _logless_roles_filter,
        generated::logless_roles,
        [(id, Scalar)]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(self, id: impl Into<i64>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
            let id = id.into();
            _params.extend([id::set(id)]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: impl Into<i64>,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            let id = id.into();
            _params.extend([id::set(id)]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::IdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Id(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Id, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Id(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
pub mod user_settings_data {
    use super::_prisma::*;
    pub const NAME: &str = "UserSettingsData";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserId(super::_prisma::read_filters::BigIntFilter),
        PinConfirm(super::_prisma::read_filters::BooleanFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::UserIs(where_params) => (
                    user::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserIsNot(where_params) => (
                    user::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserId(value) => (user_id::NAME, value.into()),
                Self::PinConfirm(value) => (pin_confirm::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        UserIdEquals(i64),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::UserIdEquals(value) => (
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        UserId(super::SortOrder),
        PinConfirm(super::SortOrder),
        User(Vec<super::user::OrderByWithRelationParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::UserId(param) => ("user_id", param.into()),
                Self::PinConfirm(param) => ("pin_confirm", param.into()),
                Self::User(param) => (
                    "user",
                    ::prisma_client_rust::PrismaValue::Object(
                        param.into_iter().map(Into::into).collect(),
                    ),
                ),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {
        User(super::user::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::User(args) => {
                    let mut selections =
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(user::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        ConnectUser(super::user::UniqueWhereParam),
        UserId(super::_prisma::write_params::BigIntParam),
        PinConfirm(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::ConnectUser(where_param) => (
                    user::NAME,
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserId(value) => (user_id::NAME, value.into()),
                Self::PinConfirm(value) => (pin_confirm::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        UserId(super::_prisma::write_params::BigIntParam),
        PinConfirm(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::UserId(value) => ("user_id", value.into()),
                Self::PinConfirm(value) => ("pin_confirm", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_user_settings_data,
        select,
        generated::user_settings_data,
        struct Data {
            #[serde(rename = "user")]
            user: user::Type,
            #[serde(rename = "user_id")]
            user_id: user_id::Type,
            #[serde(rename = "pin_confirm")]
            pin_confirm: pin_confirm::Type,
        },
        [
            (user, Relation(generated::user, One)),
            (user_id, Scalar),
            (pin_confirm, Scalar)
        ]
    );
    pub enum SelectParam {
        User(user::Select),
        UserId(user_id::Select),
        PinConfirm(pin_confirm::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::User(data) => data.into(),
                Self::UserId(data) => data.into(),
                Self::PinConfirm(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_user_settings_data,
        include,
        generated::user_settings_data,
        struct Data {
            #[serde(rename = "user")]
            user: user::Type,
            #[serde(rename = "user_id")]
            user_id: user_id::Type,
            #[serde(rename = "pin_confirm")]
            pin_confirm: pin_confirm::Type,
        },
        [(user, Relation(generated::user, One))]
    );
    pub enum IncludeParam {
        User(user::Include),
        UserId(user_id::Include),
        PinConfirm(pin_confirm::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::User(data) => data.into(),
                Self::UserId(data) => data.into(),
                Self::PinConfirm(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub user: super::user::UniqueWhereParam,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client.user_settings_data().create(self.user, self._params)
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([user::connect(self.user)]);
            self._params
        }
    }
    pub fn create(user: super::user::UniqueWhereParam, _params: Vec<SetParam>) -> Create {
        Create { user, _params }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub user_id: i64,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client
                .user_settings_data()
                .create_unchecked(self.user_id, self._params)
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([user_id::set(self.user_id)]);
            self._params
        }
    }
    pub fn create_unchecked(user_id: i64, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
        CreateUnchecked { user_id, _params }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(user_id::NAME),
                ::prisma_client_rust::sel(pin_confirm::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "user")]
        pub user: Option<user::RecursiveSafeType>,
        #[serde(rename = "user_id")]
        pub user_id: user_id::Type,
        #[serde(rename = "pin_confirm")]
        pub pin_confirm: pin_confirm::Type,
    }
    impl Data {
        pub fn user(
            &self,
        ) -> Result<&super::user::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.user
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(user),
                ))
                .map(|v| v.as_ref())
        }
    }
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_user_settings_data,
        generated::user_settings_data,
        struct Data {
            #[serde(rename = "user_id")]
            pub user_id: generated::user_settings_data::user_id::Type,
            #[serde(rename = "pin_confirm")]
            pub pin_confirm: generated::user_settings_data::pin_confirm::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _user_settings_data_filter,
        generated::user_settings_data,
        [
            (user, Relation(generated::user, One)),
            (user_id, Scalar),
            (pin_confirm, Scalar)
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            user: super::user::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            let user = user.into();
            _params.extend([user::connect(user)]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            user_id: impl Into<i64>,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            let user_id = user_id.into();
            _params.extend([user_id::set(user_id)]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod pin_confirm {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "pin_confirm";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub bool);
        pub fn equals<T: From<Equals>>(value: impl Into<bool>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::PinConfirm(_prisma::read_filters::BooleanFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            PinConfirm,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::PinConfirm(v)
            }
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::PinConfirm(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<bool>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::PinConfirm(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PinConfirm(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::PinConfirm(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PinConfirm(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PinConfirm(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "user";
        pub type Type = user::Data;
        pub type RecursiveSafeType = Box<user::Data>;
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub struct Order(Vec<user::OrderByWithRelationParam>);
        pub fn order<T: From<Order>>(v: Vec<user::OrderByWithRelationParam>) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::User(v)
            }
        }
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::User(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUser(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::User(self)
            }
        }
        impl Select {
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("user", None, [], selections)
            }
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::User(self)
            }
        }
        impl Include {
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => selections.into_iter().map(Into::into).collect(),
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(Into::into));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("user", None, [], selections)
            }
        }
    }
    pub mod user_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "user_id";
        pub type Type = i64;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub i64);
        pub fn equals<T: From<Equals>>(value: impl Into<i64>) -> T {
            Equals(value.into()).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::UserIdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::UserId(_prisma::read_filters::BigIntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            UserId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::UserId(v)
            }
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: impl Into<i64>) -> T {
            Set(value.into()).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::UserId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
            UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserId(_prisma::write_params::BigIntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::UserId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
